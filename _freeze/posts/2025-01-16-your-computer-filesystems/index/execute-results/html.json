{
  "hash": "40cf6c962af4272bdf2ae4a2de0c9b32",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to your computerʻs terminal utilities\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"So much power; or how I got my computer to do my bidding\"\ndate: 2025-01-16\n# image: \"../../images/happygitwithr.png\"\ncategories: [module 1, week 1, programming, filesystem, shell]\n---\n\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**For future lectures, Iʻll give you some reading or podcasts to prepare**\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://academind.com/tutorials/terminal-zsh-basics>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Know the shell used in your computer`s operating system.\n-   Know basic shell commands and when you might want to use them.\n-   Know how to traverse your computer`s filesystem, grab input or put output anywhere.\n-   Understand the difference between relative and absolute file paths.\n-   Know how to create and manipulate files through the shell.\n:::\n\n# Introduction to the shell\n\nThis document gives a brief explanation of your computerʻs filesystems and how we will use the command line for this course.\n\n## The kernel\n\nThe *kernel* is the part of your computerʻs operating system that loads first once you start up. It is kind of like your computerʻs autonomic nervous system. It recognizes all of the physical hardware attached to it, enables communication between components (and device drivers), and monitors maintenance functions like turning on the fan when it gets hot, manages virtual memory, gives warnings when the hard drive gets full, manages multitasking, and manages security and file permissions. In the mac this is the XNU kernel (\"X is not UNIX\"), in modern Windows machines it is the Windows NT kernel.\n\n\n\n::: {.cell .fig-cap-location-top}\n::: {.cell-output-display}\n![](https://www.linuxandubuntu.com/content/images/wordpress/2019/07/macos-kernel-resources.jpg?ssl=1)\n:::\n:::\n\n\n\\[[Source: Map of MacOS: the heart of everything is called Darwin; and within it, we have separate system utilities (the shell) and the XNU kernel, which is composed in parts by the Mach kernel and by the BSD kernel.](https://www.linuxandubuntu.com/home/difference-between-linux-kernel-mac-kernel)\\]\n\n\n## The shell\n\nThe **shell** is another key part of the core operating system (note in the diagram above it is part of the **System Utilities**, and the partner of the kernel). The shell is a software (an app) that allows humans to control the computer. You are already familiar with the *GUI* interface, or the *Graphical User Interface*. It is important that you are comfortable using the *Command Line Interface* as well.\n\n::: callout-note\n# There are many reasons to be proficient in the shell:\n- Data analysis increasingly uses many files. The shell provides a simple but very powerful means to do all kinds of operations on files: move, delete, organize, combine, rename, etc.\n- Using the shell encourages you to understand your computerʻs filesystem, and helps you to more precisely control input and output to any place along your file paths.\n- Shell operations are fast.\n- You can use wildcards to control matching or excluding many files.\n- The shell can be used to execute (run) software.\n- The shell is probably the oldest app, so it is very stable with lasting power.\n- It is part of the OS, so when your apps fail or you are having some issues, you would turn to the shell to kill troublesome processes (programs) or diagnose and fix the issues.\n:::\n\nMacs use the same terminal utilities as UNIX/Linux systems. On the Mac, the command line interface app is called *Terminal*, which you will find in your *Application* folder, in the *Utilities* subfolder (here is a screentshot of our GUI Interface).\n\n\n\n::: {.cell .fig-cap-location-top}\n::: {.cell-output-display}\n![](../../images/terminal.png)\n:::\n:::\n\n\n\nOn a PC if you installed [Git For Windows](https://happygitwithr.com/install-git), you can use _Git-Bash_ (a UNIX emulator) and follow the UNIX instructions (this would be my personal preference).  Otherwise you use the *Command Prompt* also known as the *Windows Command Processor* or *CMD*. If you used a pre-Windows machine, you would be familiar with MS-DOS. To open CMD:\n\n1. Open the Start Menu and type \"command prompt\" or\n2. Press **Win + R** and type \"cmd\" in the run box or\n3. Press **Win + X** and select Command Prompt from the menu.\n\nNote: you may see *Windows PowerShell* or *Windows Terminal* instead, these are similar apps.\n\n\n# The Working Directory\n\nBy default, the working directory on a Mac and UNIX/Linux systems is your home user directory \"\\~\". On a PC the default working directory may look something like a subdirectory of your C drive \"C:\\Users\\[Username]\\\".\n\nThis is where you currently are in your computerʻs file structure.\n\nFirst, let's check where we are by listing the files in our current directory. Note that some shell commands differ between different shells (i.e. UNIX vs. PC).\nListing the contents of a directory is done with __ls__ in UNIX and __dir__ in PC:\n\n::: {.panel-tabset}\n\n## Mac/UNIX\n\n```zsh\nls\n```\n\n## PC\n\n```default\ndir\n```\n\n:::\n\n::: callout-tip\n# An important principle of programming is **VERIFICATION**\n- **Always check that it worked** -- at each step!\n- You should check the new commands that you are learning against something that you KNOW WORKS.\n- Here, since you are familiar with the GUI, as you are doing these new command line operations, keep a GUI window open to verify.\n- You should also check on the command line by listing the directory after you add or move files etc.\n:::\n\n\n\nPlease make a folder for your work in a convenient place and call it \"Rclass\". On a Mac you may want to put it in \"Documents\". Start by navigating into your Documents folder or other such folder where you want your Rclass work to be saved. **cd** is for *change directory*, and the syntax is **cd Foldername**:\n\n```zsh\ncd Documents\n```\n\n# Making a new folder from the command Line\n\nIn both systems, the **mkdir** command for *make directory* will create a new folder, and **cd** will change directories. :\n\n::: {.panel-tabset}\n\n## Mac/UNIX\n\n```zsh\nmkdir Rclass\ncd Rclass\nls  # or dir in PC\n```\n\n## PC\n\n```default\nmkdir Rclass\ncd Rclass\ndir\n```\n\n:::\n\nYou have now created the Rclass directory, changed directory again into Rclass, and listed files. (It should be empty.)\n\nThis seems like a lot of trouble, when you can just point and click in the GUI. But the beauty of the shell is its power. We can automate actions, execute code, and use wildcards to do many at once (coming up below).\n\nLetʻs say you wanted to create files in a new subfolder. **touch** is a command that creates a new (empty) file, or alters the timestamp of existing files.\n\n::: {.panel-tabset}\n\n## Mac/UNIX\n```zsh\nmkdir shell\ncd shell\ntouch dat.txt  # PC does not have the touch function\n```\n\n## PC\n```zsh\nmkdir shell\ncd shell\ntype nul > dat.txt  # for PC use type nul with pipe instead of touch\n```\n:::\n\nCheck that you have a subfolder within Rclass that has one file named dat.txt.\n\nSuppose we wanted to create 10 files.  You can so easily in the UNIX shell:\n\n```zsh\ntouch dat{1..10}.txt  # for PC type nul > dat1.txt multiple times\n```\n\n::: {.panel-tabset}\n\n## Mac/UNIX\n\nTo check your files timestamps list files with the -l flag:\n\n```zsh\nls -l\n```\n\nThe -a flag shows hidden files. You can do both at once:\n\n```zsh\nls -la\n```\n\n## PC\n\nThe **dir** command provides the timestamp as well as other information.\n\n```zsh\ndir\n```\n:::\n\n::: callout-note\n# Exercise:\n\n1. Create 20 files with the .jpg file extension.\n2. List your files now.\n3. Create 2 subdirectories, one called \"Data\" and one called \"Images\"\n:::\n\n# More useful commands: **move** **copy** **remove** and friends\n\nSome additional very useful commands are those for moving, copying, and removing (deleting) files.  These can operate on your current directory, or you can add the *path* to your file. For example, to move your file into the Data subdirectory:\n\n```zsh\nmv dat1.txt Data/dat1.txt\nls\nls Data\n```\nAnywhere where you can indicate a filename, you can also add a path to that file.\n\n| function | UNIX | Windows CMD |  example |\n|------|-------|---------|----- |\n| move | mv filename newlocation | move filename newlocation | mv dat1.txt Data |\n| copy | cp filename newfilename | copy filename newfilename | cp dat1.txt catcat.txt |\n| remove | rm filename | del filename | rm dat1.txt |\n| remove directory | rmdir Directory | rmdir Directory | rmdir Data |\n| concatenate (combine) | cat file1 file2 | cat file1 file2 | cat dat1.txt dat2.txt |\n| concatenate to new file | cat file1 file2 > file3 | cat file1 file2 > file3 | cat dat1.txt dat2.txt > alldat.txt |\n| list files | ls | dir | |\n| get working directory | pwd | cd | |\n\n*Note: UNIX commands are case-sensitive, Windows commands are not.*\n*Apologies in advance for any Windows command errors - Iʻm really not an expert. Please let me know so I can fix it. Thank you!*\n\n# Wildcards\n\nYou can also select multiple files at once using wildcards. If you want to grab all of the .txt files, for example, you can do:\n\n```zsh\ncp *.txt Data\nls  # PC: use dir\nls Data # PC: use dir Data\n```\n\nAnd you should have copied *all* files that end in .txt into Data.  You could alternatively used dat* which will select all files that begin with \"dat\" but can end in anything else.  The * will match any characters (zero or more).\n\nThere are a lot of other wildcards that you can use.\n\n::: callout-note\n# Exercise:\n\n1. Move all of your data files into Data, and all of your image files into Images.\n2. Remove any straggler files from the top level of shell, if you used the copy command.\n3. List files from shell, Data, and Images.\n:::\n\n# Relative paths vs. Absolute paths\n\nIn the Mac, there are two important *shortcuts*:\n\n-  \"/\" : The root directory of your entire computer, indicated by \"/\".\n-  \"~\" : The root of your user directory, which for me is \"marguerite\". From the root directory, it will be \"/Users/username\"\n\nIn PCs, your root user directory in CMD is usually something like:\n\n- \"C:\\\\User\\\\username\\\" : this would be the root of your user Directory\n- The root of the C drive is \"C:\\\"\n\n::: callout-note\n# Note:\nOn PCs pay attention to the direction of the slashes when you type **dir** is it \"/\" or \"\\\\\" ? When you type your filepaths, be sure to use the right type of slash.\n:::\n\nCheck out what is in these directories:\n\n::: {.panel-tabset}\n\n## Mac/UNIX\n\n```zsh\nls /\nls ~\n```\n## PC\n\nShortcuts in Windows are called Windows Environment Path Variables:\n```zsh\ndir %UserProfile%  # is this C:\\\\Users\\\\{username} ?\ndir %SystemDrive%   # is this C: ?\n```\nWith the advent of the OneDrive, there is now a parallel user directory in OneDrive that also has Documents, etc.\n\nDonʻt get confused! \"C:\\\" drive is not the \"OneDrive\". (the OneDrive is a location on your hard drive, sometimes on C:, sometimes on D:) Windows makes use of a lot of symbolic links to make it easier for the user. These are different directories, sometims on different drives or partitions, but to the user it looks like theyʻre in the same folder). Symbolic links can be generally used in filepaths, but it can be very confusing if you accidentally end up with a circular reference or when you need to find the actual location on the hard drive.\n\nUse the \"\\\\ad\" flag with **dir** to see all of the symbolic links too. They call these symbolic links *namespace junctions*.\n\n```zsh\ndir %UserProfile% \\\\ad\n```\n:::\n\nYou can use these as shortcuts as starting points for your path to basically write an absolute path. This becomes important when you write a script that may be moved to different locations or shared with different people on different computers.\n\nFor example, \"cd ~/Documents\" will take you to the Documents folder inside your user directory, regardless of where you are currently because it is an **absolute path**.\n\nA **relative path** will traverse the file directory *relative* to where you are currently. For example \"Documents\" will start at current working directory and look for a subfolder called Documents:\n\n```zsh\nls Documents  # relative path, is there a Documents folder here?\n```\n\nIn contrast, an absolute path will start from the very beginning of your root directory and contain the complete path.\n\n```zsh\nls ~/Documents # this is an absolute path because ~ = \"\\Users\\marguerite\"\n```\n\nOn the Mac, an asbolute path will start with \"/\" (or a shortcut that contains a starting \"/\"), whereas on a PC an absolute path will start with \"C:\"\n\n\n# Navigating your file directories\n\n## The dots\n\n- \".\" is the current working directory (where you are currently)\n- \"..\" is the directory one level up\n- \"./foldername\" will take you to the folder one level down, for example \"./Data\"\n\nYou can use these paths to change directories using *cd*  or to list *ls* the contents of the directories or to make new directories using *mkdir*\n\n```zsh\nls .\nls ./Data\nmkdir ./Data/A\n```\nMake multiple directories:\n\n```zsh\nmkdir ./Data/B ./Data/C\n```\n\nList the files one level up or two levels up:\n\n```zsh\nls ..  # for PC use dir ..\nls ../..\n```\n\nUp one level, and over to another directory:\n\n```zsh\nls ../AnotherDirectory\n```\n\nYou can wander anywhere along your computerʻs file directory! Just add more steps to the path.\n\n# Executing software from the command Line\n\nThe command line is the OG (original) method for using your computer. You can of course run software from the command line as well, not just UNIX or shell commands. For example, you can run R from a unix shell using: \n\n::: {.panel-tabset}\n\n## Mac/UNIX\n\n```zsh\nR\n```\n::: \n\nWhich will launch R within the console, and look something like this: \n\n\n\n::: {.cell .fig-cap-location-top}\n::: {.cell-output-display}\n![](../../images/R_command.png)\n:::\n:::\n\n\n\nInvoke help by typing: \n\n```zsh\nls help.start()\n```\n\nAnd quit with: \n\n```zsh\nq()\n```\nChoose \"n\" when asked if you want to save workspace image.\n\n# Piping commands\n\nYou can redirect output using *>*  and *<* with the point indicating the direction.  Here is an example. First letʻs put some contents into the files, and check the contents with the command \"less\" (there is also \"more\"):\n\n```zsh\necho \"A\" > dat1.txt\nless dat1.txt\n```\n\n*>* pipes (or sends) output to the file named \"dat1.txt\".  If the file doesnʻt exist, it will create it. If it already exists, it will *replace* the file.\n\nIf you want to add on to the file, use \">>\"\n\n```zsh\necho \"Another letter B\" >> dat1.txt\nless dat1.txt\n```\nOutput to multiple files:\n\n```zsh\necho \"c\" >dat2.txt >dat3.txt\nless dat2.txt\nless dat3.txt\n```\n\nConcatenate (combine) multiple files using *cat* and send it to file\n\n```zsh\ncat dat1.txt dat2.txt dat3.txt\ncat dat1.txt dat2.txt dat3.txt >all.txt\nless all.txt\n```\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  What is a command line interface?\n\n2.  How can using the command line help with file organization or reorganization?\n\n3.  What is the importance of choosing a good file naming system?\n\n4.  What is the difference between a relative path and an absolute path?\n:::\n\n::: callout-note\n### For additional practice:\n\n1. Practice making directories with subdirectories A, B, etc. with several levels A1 A2 etc.\n\n2. Practice moving files between different directories and at different levels.\n\n3. Practice moving junk lying around in your downloads folder into the trash using the command line (or at least putting them into a common folder \"opala\" folder which you can then manually put into the trash). (FYI on the Mac Trash is in \"~/.Trash\" so it is a hidden folder)\n:::\n\n\n::: callout-important\n### In Preparation for Next Time:\n\n1.  Install git. Follow instructions at for Mac or PC at \\[[Happy Git and GitHub for the useR](https://happygitwithr.com/install-git)\\] For Windows install, installation of \"Git-Bash\" is highly recommended. \n\n2.  Create an account at GitHub \\[[advice here](https://happygitwithr.com/github-acct)\\]\n:::\n\n### Additional Resources\n\n::: callout-tip\n- [A tutorial for zsh on Macs](https://academind.com/tutorials/terminal-zsh-basics)\n- [Bash shell cheat sheet (mostly works for zsh too)](https://www.educative.io/blog/bash-shell-command-cheat-sheet)\n- [A tutorial for CMD on PCs](https://www.makeuseof.com/tag/a-beginners-guide-to-the-windows-command-line/)\n- [Windows CMD cheat sheet](https://serverspace.us/support/help/windows-cmd-commands-cheat-sheet/)\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}