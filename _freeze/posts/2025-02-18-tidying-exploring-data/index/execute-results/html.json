{
  "hash": "c7ce20f4f89416cfbde646181e478925",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidying and Exploring Data\"  \nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"All about data and how it is represented in R\"  \ndate: 2025-02-18\ncategories: [module 2, week 4, data, data structures, objects]  \n---\n\n\n\n<!-- Add interesting quote -->\n\n<!-- R emoji aliases:  https://gist.github.com/rxaviers/7360908 -->\n✏️\n\n# Overview \n\nAs a biologist, these data manipulation topics may seem dry, but they are really powerful and will allow you do to much more sophisticated analyses, and to do them with confidence. \n\nThere are two main steps in the data analysis pipeline where these skills become critical: \n\n1.  Tyipcally, we canʻt even look at the data in any meaningful way unless we can pluck out the parts we need or reshape the data.  We can then do the intial data exploration and assessment. \n2.  The __data processing__ step where we convert _raw data_ to _analytical data_. \n    + Is the data clean of typos, or errors? \n    + How do we want to deal with missing data? \n    + Do we need to transform the data?\n    + Do we want to take summary statistics (i.e, species means, etc.)?\n    + Do we need to reshape the data for downstream analyses?\n\nVetting and reorganizing the data can take more programming time and effort than the actual statistical analyses. These tools will be a huge help, so it is well worth taking some time to learn how to use them well. \n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will know how to use:**\n\n* __Indexing__ accessing particular elements of your data object \n* __Matching__ using logical comparisons to index an entire object\n* __Subsetting__ saving subsets of your data, often with indexing\n* __String Matching__ and replacement using `grep()`, `sub()`\n* __Sorting__ reordering data\n:::\n\n\n\n# Indexing\n\n\nIn general, accessing elements of vectors, matrices, or dataframes is achieved through __indexing__ by *__position__* or *__name__*. \n\nThis is extremely useful for selecting relevant data, excluding irrelevant data, or selcting building blocks to form new objects. \n\nThere are many ways to achieve this:\n\n*  __inclusion__ a vector of positive integers indicating which elements of the vector to include\n*  __exclusion__ a vector of negative integers\n*  __logical values__ a vector of TRUE / FALSE values indicating which elements to include / exclude\n*  __by name__ a character vector of names of columns (only) or columns and rows\n*  __blank index__ take the entire column, row, or object\n*  __missing values__ can be indexed in much the same way, but because they *match ALL values* -- you have to use the `is.na()` function.\n\n## Vectors\n\nThe __index__ of a vector is it's number in the array. Each and every element in any data object has at least one index (if vector, it is one dimensional so it is its position along the vector, if a matrix or data frame, which are two-dimensional, it's the row and column number, etc.)\n\nLet's create a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- c(1, 5, 2, 3, 5)\nxx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 2 3 5\n```\n\n\n:::\n:::\n\n\n\nAccess specific values of `xx` by number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nYou can use a function to generate an index. Get the last element (without knowing how many there are) by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx[length(xx)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\nRetrieve multiple elements of `xx` by using a __vector__ as an argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx[c(1, 3, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 2\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[c(1, length(xx))]  # first and last\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5\n```\n\n\n:::\n:::\n\n\n\nExclude elements by using a negative index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 2 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[-1]  # exclude first\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 2 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[-2] # exclude second\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[-(1:3)] # exclude first through third\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[-c(2, 4)] # exclude second and fourth, etc. \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 5\n```\n\n\n:::\n:::\n\n\n\nUse a logical __vector__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx[ c( T, F, T, F, T) ]  # T is the same as TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxx > 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[ xx > 2 ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nxx > 2 & xx < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nxx[ xx>2 & xx<5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n__Subsetting__ (picking particular observations out of an R object) is something that you will have to do all the time. It's worth the time to understand it clearly.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset_xx <-  xx[ xx > 2 ]\nsubset_xx2 <- subset(xx, xx>2)  # using subset function\nsubset_xx == subset_xx2   # check if the same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE TRUE\n```\n\n\n:::\n:::\n\n\n\nThe `subset` function is just another way of subsetting by index, just in function form with arguments. It can be more clear to use for __dataframes__, but it is really a matter of personal preference as you develop your style. Whichever way you go, it is important to be aware of the different ways to achieve the same goals. \n\n\n## Matrices and Dataframes\n\n__Matrices__ and __dataframes__ are both rectangular having two dimensions, and are handled very similarly for indexing and subsetting. \n\nLet's work with a dataframe that is provided with the `geiger` package called `geospiza`. It is a list with a tree and a dataframe. The dataframe contains five morphological measurements for 13 species. First, let's clear the workspace (or clear and start a new R session):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"geiger\")  # if you need to install geiger\n```\n:::\n\n\n\nGet the built-in dataset this way:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\nlibrary(geiger)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ape\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: phytools\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: maps\n```\n\n\n:::\n\n```{.r .cell-code}\ndata(geospiza)   # load the dataset into the workspace\nls()               # list the objects in the workspace\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"geospiza\"\n```\n\n\n:::\n:::\n\n\n\nLet's find out some basic information about this object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(geospiza)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(geospiza)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"geospiza.tree\" \"geospiza.data\" \"phy\"           \"dat\"          \n```\n\n\n:::\n\n```{.r .cell-code}\nstr(geospiza)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ geospiza.tree:List of 4\n  ..$ edge       : num [1:26, 1:2] 15 16 17 18 19 20 21 22 23 24 ...\n  ..$ edge.length: num [1:26] 0.2974 0.0492 0.0686 0.134 0.1035 ...\n  ..$ Nnode      : int 13\n  ..$ tip.label  : chr [1:14] \"fuliginosa\" \"fortis\" \"magnirostris\" \"conirostris\" ...\n  ..- attr(*, \"class\")= chr \"phylo\"\n $ geospiza.data: num [1:13, 1:5] 4.4 4.35 4.22 4.26 4.24 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:13] \"magnirostris\" \"conirostris\" \"difficilis\" \"scandens\" ...\n  .. ..$ : chr [1:5] \"wingL\" \"tarsusL\" \"culmenL\" \"beakD\" ...\n $ phy          :List of 4\n  ..$ edge       : num [1:26, 1:2] 15 16 17 18 19 20 21 22 23 24 ...\n  ..$ edge.length: num [1:26] 0.2974 0.0492 0.0686 0.134 0.1035 ...\n  ..$ Nnode      : int 13\n  ..$ tip.label  : chr [1:14] \"fuliginosa\" \"fortis\" \"magnirostris\" \"conirostris\" ...\n  ..- attr(*, \"class\")= chr \"phylo\"\n $ dat          : num [1:13, 1:5] 4.4 4.35 4.22 4.26 4.24 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:13] \"magnirostris\" \"conirostris\" \"difficilis\" \"scandens\" ...\n  .. ..$ : chr [1:5] \"wingL\" \"tarsusL\" \"culmenL\" \"beakD\" ...\n```\n\n\n:::\n:::\n\n\n\nIt is a list with four elements. Here we want the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo <- geospiza$geospiza.data\ndim(geo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13  5\n```\n\n\n:::\n:::\n\n\n\nIts a rectangle of data, but let's see what type of object it is: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(geo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\nIt is a matrix, but we want to work with a dataframe, so let's coerce it: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo <- as.data.frame(geo)\n```\n:::\n\n\nIf we want to know all the attributes of geo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(geo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"wingL\"   \"tarsusL\" \"culmenL\" \"beakD\"   \"gonysW\" \n\n$class\n[1] \"data.frame\"\n\n$row.names\n [1] \"magnirostris\" \"conirostris\"  \"difficilis\"   \"scandens\"     \"fortis\"      \n [6] \"fuliginosa\"   \"pallida\"      \"fusca\"        \"parvulus\"     \"pauper\"      \n[11] \"Pinaroloxias\" \"Platyspiza\"   \"psittacula\"  \n```\n\n\n:::\n:::\n\n\nIt is a dataframe with 13 rows and 5 columns. \nWe see that it has a \"names\" attribute, which refers to column names in a dataframe. Typically, the columns of a dataframe are the variables in the dataset. It also has \"rownames\" which contains the species names (so it does not have a separate column for species names). \n\nDataframes have two dimensions which we can use to index with:  dataframe[row, column]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo     # the entire object, same as geo[] or geo[,]\ngeo[c(1, 3), ]   # select the first and third rows, all columns\ngeo[, 3:5]   # all rows, third through fifth columns\ngeo[1, 5]  # first row, fifth column (a single number)\ngeo[1:2, c(3, 1)]  # first and second row, third and first column (2x2 matrix)\ngeo[-c(1:3, 10:13), ]  # everything but the first three and last three rows\ngeo[ 1:3, 5:1]  # first three species, but variables in reverse order\n```\n:::\n\n\n\nTo prove to ourselves that we can access matrices in the same way, let's coerce geo to be a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeom <- as.matrix( geo ) \nclass(geom)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(geo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngeo[1,5]  # try a few more from the choices above to test\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.675983\n```\n\n\n:::\n:::\n\n\n\nSince `geo` and `geom` have row and column names, we can access by name (show that this works for `geom` too):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo[\"pauper\", \"wingL\"]  # row pauper, column wingL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2325\n```\n\n\n:::\n\n```{.r .cell-code}\ngeo[\"pauper\", ]  # row pauper, all columns \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        wingL tarsusL culmenL  beakD gonysW\npauper 4.2325  3.0359   2.187 2.0734 1.9621\n```\n\n\n:::\n:::\n\n\n\nWe can also use the names (or rownames) attribute if we are lazy. Suppose we wanted all the species which began with \"pa\". we could find which position they hold in the dataframe by looking at the rownames, saving them to a vector, and then indexing by them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp <- rownames(geo)\nsp                            # a vector of the species names\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"magnirostris\" \"conirostris\"  \"difficilis\"   \"scandens\"     \"fortis\"      \n [6] \"fuliginosa\"   \"pallida\"      \"fusca\"        \"parvulus\"     \"pauper\"      \n[11] \"Pinaroloxias\" \"Platyspiza\"   \"psittacula\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nsp[c(7,8,10)]     # the ones we want are #7,8, and 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pallida\" \"fusca\"   \"pauper\" \n```\n\n\n:::\n\n```{.r .cell-code}\ngeo[ sp[c(7,8,10)], ]  # rows 7,8 and 10, same as geo[c(7, 8, 10)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           wingL  tarsusL  culmenL    beakD   gonysW\npallida 4.265425 3.089450 2.430250 2.016350 1.949125\nfusca   3.975393 2.936536 2.051843 1.191264 1.401186\npauper  4.232500 3.035900 2.187000 2.073400 1.962100\n```\n\n\n:::\n:::\n\n\n\nOne difference between dataframes and matrices is that Indexing a data frame by a single vector (meaning, no comma separating) selects an entire column.  This can be done by name or by number:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo[3]   # third column\ngeo[\"culmenL\"]  # same\ngeo[c(3,5)]  # third and fifth column\ngeo[c(\"culmenL\", \"gonysW\")]  # same\n```\n:::\n\n\nProve to yourself that selecting by a single index has a different behavior for matrices (and sometimes produces an error.  \n\n:::{.callout-tip}\n## Why?\n- Because internally, a dataframe is actually a list of vectors. Thus a single name or number refers to the column, rather than a coordinate in a cartesian-coordinate-like system. \n- However, a matrix is actually a vector with breaks in it. So a single number refers to a position along the single vector. \n- A single name could work, but only if the individual elements of the matrix have names (like naming the individual elements of a vector).\n:::\n\n\n\nAnother difference is that dataframes (and lists below) can be accessed by the `$` operator. It means indicates a column within a dataframe, so `dataframe$column`. This is another way to select by column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo$culmenL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2.724667 2.654400 2.277183 2.621789 2.407025 2.094971 2.430250 2.051843\n [9] 1.974420 2.187000 2.311100 2.331471 2.259640\n```\n\n\n:::\n:::\n\n\n\nAn equivalent way to index is by using the `subset` function. Some people prefer it because you have explicit parameters for what to select and which variables to include. See help page `?subset`. \n\n## Lists\n\nA list is a vector, except that whereas an ordinary vector has the same type of data (numeric, character, factor) in each slot, a list can have different types in different slots. They are sort of like expandable containers, flexibly accommodating any group of objects that the user wants to keep together.\n\nThey are accessed by numeric index or by name (if they are named), but they are accessed by double square brackets. Also, you can't access multiple elements of lists by using vectors of indices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list( vec = 2*1:10, mat = matrix(1:10, nrow=2), cvec = c(\"frogs\", \"birds\"))\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$vec\n [1]  2  4  6  8 10 12 14 16 18 20\n\n$mat\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\n$cvec\n[1] \"frogs\" \"birds\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmylist[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n\n```{.r .cell-code}\nmylist[[\"vec\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n\n```{.r .cell-code}\n# mylist[[1:3]]  # gives an error if you uncomment it\nmylist$cvec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"frogs\" \"birds\"\n```\n\n\n:::\n:::\n\n\n\n# String Matching\n\nA very useful feature is string matching. R has `grep` facilities, which can do partial matching of character strings. This is different from the ordinary `==` operator, which will compare whole character strings. Partial matching is really helpful when you are not sure of the spelling, looking for typos, variations, etc. For example, we could directly search for species (the object or \"x\") names which contain \"p\" (the pattern):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp <- rownames(geo)\ngrep(pattern = \"p\", x = sp)  # returns indices   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  7  9 10 12 13\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"p\", sp, value=T)  # returns the species names which match\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pallida\"    \"parvulus\"   \"pauper\"     \"Platyspiza\" \"psittacula\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"p\", sp, ignore.case=T, value=T)   # case-sensitive by default\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pallida\"      \"parvulus\"     \"pauper\"       \"Pinaroloxias\" \"Platyspiza\"  \n[6] \"psittacula\"  \n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"^P\", sp, value=T)  # only those which start with (^) capital P\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Pinaroloxias\" \"Platyspiza\"  \n```\n\n\n:::\n:::\n\n\n\nIt is possible to use perl-type regular expressions, and the sub function is also available. `sub` is related to `grep`, but substitutes a replacement value to the matched pattern. Notice that there are two species which have upper case letters. We can fix this with:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp <- rownames(geo)\nsub(pattern = \"^P\", replacement = \"p\", sp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"magnirostris\" \"conirostris\"  \"difficilis\"   \"scandens\"     \"fortis\"      \n [6] \"fuliginosa\"   \"pallida\"      \"fusca\"        \"parvulus\"     \"pauper\"      \n[11] \"pinaroloxias\" \"platyspiza\"   \"psittacula\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nrownames(geo) <- sub(pattern = \"^P\", replacement = \"p\", sp)   # to save changes\n```\n:::\n\n\n\n# Ordering Data\n\nSuppose we now want geo in alphabetical order. We can use the `sort` function to sort the rownames vector, then use it to index the dataframe:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(rownames(geo))\ngeo[ sort(rownames(geo)), ]\n```\n:::\n\n\n\nA better option for dataframes, though, is `order`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder(rownames(geo))   # the order that the species should take to be\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  3  5  6  8  1  7  9 10 11 12 13  4\n```\n\n\n:::\n\n```{.r .cell-code}\n                 #  sorted from a-z\nrbind(rownames(geo), order(rownames(geo)))  # to illustrate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]           [,2]          [,3]         [,4]       [,5]     [,6]        \n[1,] \"magnirostris\" \"conirostris\" \"difficilis\" \"scandens\" \"fortis\" \"fuliginosa\"\n[2,] \"2\"            \"3\"           \"5\"          \"6\"        \"8\"      \"1\"         \n     [,7]      [,8]    [,9]       [,10]    [,11]          [,12]       \n[1,] \"pallida\" \"fusca\" \"parvulus\" \"pauper\" \"pinaroloxias\" \"platyspiza\"\n[2,] \"7\"       \"9\"     \"10\"       \"11\"     \"12\"           \"13\"        \n     [,13]       \n[1,] \"psittacula\"\n[2,] \"4\"         \n```\n\n\n:::\n\n```{.r .cell-code}\noo <- order(rownames(geo))\ngeo[oo,]   # sorted in alpha order\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                wingL  tarsusL  culmenL    beakD   gonysW\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100 1.929983\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nfuliginosa   4.132957 2.806514 2.094971 1.941157 1.845379\nfusca        3.975393 2.936536 2.051843 1.191264 1.401186\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\npallida      4.265425 3.089450 2.430250 2.016350 1.949125\nparvulus     4.131600 2.973060 1.974420 1.873540 1.813340\npauper       4.232500 3.035900 2.187000 2.073400 1.962100\npinaroloxias 4.188600 2.980200 2.311100 1.547500 1.630100\nplatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\n```\n\n\n:::\n:::\n\n\n\n## Multiple arguments - breaking ties\n\nOrder can sort on multiple arguments, which means that you can use other columns to break ties. Let's trim the species names to the first letter using the substring function, then sort using the __first letter of the species name__ and breaking ties by __tarsusL__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp <- substring(rownames(geo), first=1, last=1)\noo <- order(sp , geo$tarsusL) # order by first letter species, then tarsusL\ngeot <- geo[oo,][\"tarsusL\"]   # ordered geo dataframe, take only the wingL column\ngeo <- geo[oo,]\n```\n:::\n\n\n\n::: {.callout-tip}\n## Note: \n\n- Using `geo[\"tarsusL\"]` as a second index for order doesn't work, because it is a __one column dataframe__, as opposed to `geo$tarsus` which is a __vector__. \n- The object must match `sp`, which is a __vector__. Check the `dim` and `length` of each. \n- vectors only have __length__, dataframes have __dimensions__ (dim=2 for numbers of rows, columns).           \n- __Check your objects!__ The shapes have to be of the right __class__ even if they contain the same information.  This is because functions are written for particular classes of objects (and sometimes the programmer didnʻt write one for your type of object).\n- You can always coerce your object to the right class using `as.vector`, `as.dataframe`, etc. and try again.\n:::\n\n# Matching\n\nMatching is very easy in R, and is often used to create a logical vector to subset objects. Greater than and less than are as usual, but logical equal is two equal signs \"==\" to differentiate from the assignment operator \"=\". Also >= and <=.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeot > 3    # a logical index \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             tarsusL\nconirostris    FALSE\ndifficilis     FALSE\nfuliginosa     FALSE\nfortis         FALSE\nfusca          FALSE\nmagnirostris    TRUE\nparvulus       FALSE\npinaroloxias   FALSE\npauper          TRUE\npsittacula      TRUE\npallida         TRUE\nplatyspiza      TRUE\nscandens       FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ngeot == 3  # must match exactly 3, none do\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             tarsusL\nconirostris    FALSE\ndifficilis     FALSE\nfuliginosa     FALSE\nfortis         FALSE\nfusca          FALSE\nmagnirostris   FALSE\nparvulus       FALSE\npinaroloxias   FALSE\npauper         FALSE\npsittacula     FALSE\npallida        FALSE\nplatyspiza     FALSE\nscandens       FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ngeot[ geot > 3 ]   # use to get observations which have tarsus > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.038950 3.035900 3.049120 3.089450 3.270543\n```\n\n\n:::\n\n```{.r .cell-code}\n#  ii <- geot > 3    # these two lines of code accomplish the same\n#  geot[ii]\ncbind(geo[\"tarsusL\"], geot > 3)  # check\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              tarsusL tarsusL\nconirostris  2.984200   FALSE\ndifficilis   2.898917   FALSE\nfuliginosa   2.806514   FALSE\nfortis       2.894717   FALSE\nfusca        2.936536   FALSE\nmagnirostris 3.038950    TRUE\nparvulus     2.973060   FALSE\npinaroloxias 2.980200   FALSE\npauper       3.035900    TRUE\npsittacula   3.049120    TRUE\npallida      3.089450    TRUE\nplatyspiza   3.270543    TRUE\nscandens     2.929033   FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ngeo[geot>3, ][\"tarsusL\"]  # what does this do?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              tarsusL\nmagnirostris 3.038950\npauper       3.035900\npsittacula   3.049120\npallida      3.089450\nplatyspiza   3.270543\n```\n\n\n:::\n:::\n\n\n\nMatching and subsetting works really well for replacing values. Suppose we thought that every measurement that was less than 2.0 was actually a mistake. We can remove them from the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo [ geo<2 ] <- NA\n```\n:::\n\n\n\n## Missing Values\n\n__Missing values compared to anything else will return a missing value__ (so NA == NA returns NA, which is usually not what you want). You must test it with `is.na` function. You can also test multiple conditions with and (`&`) and or (`|`)  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(geo$gonysW) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[13]  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ngeo[!is.na(geo$gonysW) & geo$wingL > 4, ]  # element by element \"and\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                wingL  tarsusL  culmenL    beakD   gonysW\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\nplatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\n```\n\n\n:::\n\n```{.r .cell-code}\ngeo[!is.na(geo$gonysW) | geo$wingL > 4, ]   # element by element \"or\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                wingL  tarsusL  culmenL    beakD   gonysW\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100       NA\nfuliginosa   4.132957 2.806514 2.094971       NA       NA\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\nparvulus     4.131600 2.973060       NA       NA       NA\npinaroloxias 4.188600 2.980200 2.311100       NA       NA\npauper       4.232500 3.035900 2.187000 2.073400       NA\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\npallida      4.265425 3.089450 2.430250 2.016350       NA\nplatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\n```\n\n\n:::\n:::\n\n\n\nMatching works on strings also:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo[rownames(geo) == \"pauper\",]   # same as   geo[\"pauper\", ]\ngeo[rownames(geo) < \"pauper\",]\n```\n:::\n\n\n\nThere are even better functions for strings, though. In the expression  `A %in% B`, the `%in%` operator compares two vectors of strings, and tells us which  elements of `A` are present in `B`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewsp <- c(\"clarkii\", \"pauper\", \"garmani\")\nnewsp[newsp  %in% rownames(geo)]     # which new species are in geo?\n```\n:::\n\n\n\nWe can define the \"without\" operator: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"%w/o%\" <- function(x, y) x[!x %in% y]\nnewsp  %w/o% rownames(geo)   # which new species are not in geo?\n```\n:::\n\n\n\n# Explore a new Dataset\n\n![Meet the Penguins](../../images/penguins.png)\n\nWe are going to look at the [**Palmer Penguins** dataset](https://allisonhorst.github.io/palmerpenguins/articles/intro.html).  It is a dataset of morphometric data from three species of penguins from Antarctica. \n\n![Penguin Beaks](../../images/culmen_depth.png)\n\n\nPlease practice some of the base R functions we covered today. One of the first tasks of data exploration is \n\n* counting sample size\n* identifying the variables\n* creating bivariate plots of each pair of continuous variables\n* exploring the distribution of the data\n* plots of the whole dataset versus by group (here, species)\n\nSome of the functions you could use are the following: `plot()`, `points()` `lines()`, `hist()` and `density()`. You can also assign different colors using the `col=\"red\"` etc. argument within each of these functions. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"palmerpenguins\")\n```\n:::\n\n\n\nLoad the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(palmerpenguins)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: palmerpenguins\n```\n\n\n:::\n\n```{.r .cell-code}\ndata(penguins)\n```\n:::\n\n\n\nTo read the help page, type `?penguins`. It is a __tibble__ which is the __tidyverse__ version of __data frames__.  All of our base functions will work on this. Try `summary(penguins)`\n\n\nHow many species?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Adelie    Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n```\n\n\n:::\n:::\n\n\n\n## Plot()\n\nFor a generic x-y plot use plot(). It will also start a graphical device. \n\nHere we are using the `with()` function to specify which dataframe to look into for our named variables. We could instead do `penguins$body_mass_g`, etc. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(penguins, plot( body_mass_g, bill_length_mm))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n\nTo add points to an existing plot, use `points()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(penguins, plot( body_mass_g, bill_length_mm))\nwith(penguins[penguins$species==\"Adelie\",], points( body_mass_g, bill_length_mm, col=\"red\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n\nOne could fit linear models, for example, and use `lines()` to overlay the line on the plot. \n\n## Distribution using hist() and density()\n\nTo see a histogram, use `hist()`. You can change the `breaks` and many other features by checking out the help page `?hist`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(penguins, hist( body_mass_g ))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n\nTo see a density plot use `density()` to create the density, then plot it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndens <- with(penguins, density( body_mass_g, na.rm=T ))\nplot(dens)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}