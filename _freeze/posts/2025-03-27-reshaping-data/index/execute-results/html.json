{
  "hash": "e574afeee1881cbd159cc270ebf802ec",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Reshaping data with dplyr\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Add\"\ndate: 2023-03-09\ncategories: [module 4, week 8, tidyr, tidyverse, dplyr, tibble]\n---\n\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/tidy-data>\n2.  [tidyr cheat sheet from RStudio](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-08-tidy-data-and-the-tidyverse/>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to transform wide data into long data\n-   Be able to separate character columns into multiple columns\n-   Be able to unite/separate multiple character columns into one column\n:::\n\n# Overview\n\nCommon data table reshaping tasks include reshaping your matrices or dataframes manually, or converting between __short-wide__ to __tall-thin__ formats. \n\n# Manual reshaping\n\nRecall from our discussion on data objects that internally, R objects are stored as one huge vector. The various shapes of objects are simply created by R knowing where to break the vector into rows and columns. So it is very easy to reshape matrices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvv <- 1:10  # a vector\nmm <- matrix( vv, nrow=2)  # a matrix\nmm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(mm) <- NULL\nmm <- matrix( vv, nrow=2, byrow=T)  # a matrix, but cells are now filled by row\nmm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(mm) <- NULL\nmm  # vector is now n a different order because the collapse occurred by column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  6  2  7  3  8  4  9  5 10\n```\n\n\n:::\n:::\n\n\n\nLoad the geospiza data: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(geiger)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: geiger\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ape\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: phytools\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: maps\n```\n\n\n:::\n\n```{.r .cell-code}\ndata(geospiza)   # load the dataset into the workspace\ngeo <- geospiza$dat  # save the morphometric data as geo\n```\n:::\n\n\n\nOther means of \"collapsing\" dataframes are:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(geo)   # produces a vector from the dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                wingL  tarsusL  culmenL    beakD   gonysW\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100 1.929983\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nfuliginosa   4.132957 2.806514 2.094971 1.941157 1.845379\npallida      4.265425 3.089450 2.430250 2.016350 1.949125\nfusca        3.975393 2.936536 2.051843 1.191264 1.401186\nparvulus     4.131600 2.973060 1.974420 1.873540 1.813340\npauper       4.232500 3.035900 2.187000 2.073400 1.962100\nPinaroloxias 4.188600 2.980200 2.311100 1.547500 1.630100\nPlatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\n```\n\n\n:::\n\n```{.r .cell-code}\n            # the atomic type of a dataframe is a list\nunclass(geo)  # removes the class attribute, turning the dataframe into a \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                wingL  tarsusL  culmenL    beakD   gonysW\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100 1.929983\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nfuliginosa   4.132957 2.806514 2.094971 1.941157 1.845379\npallida      4.265425 3.089450 2.430250 2.016350 1.949125\nfusca        3.975393 2.936536 2.051843 1.191264 1.401186\nparvulus     4.131600 2.973060 1.974420 1.873540 1.813340\npauper       4.232500 3.035900 2.187000 2.073400 1.962100\nPinaroloxias 4.188600 2.980200 2.311100 1.547500 1.630100\nPlatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\n```\n\n\n:::\n\n```{.r .cell-code}\n            # series of vectors  plus any names attributes, same as setting \n            # class(geo) <- NULL\nc(geo)  # similar to unclass but without the attributes            \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4.404200 4.349867 4.224067 4.261222 4.244008 4.132957 4.265425 3.975393\n [9] 4.131600 4.232500 4.188600 4.419686 4.235020 3.038950 2.984200 2.898917\n[17] 2.929033 2.894717 2.806514 3.089450 2.936536 2.973060 3.035900 2.980200\n[25] 3.270543 3.049120 2.724667 2.654400 2.277183 2.621789 2.407025 2.094971\n[33] 2.430250 2.051843 1.974420 2.187000 2.311100 2.331471 2.259640 2.823767\n[41] 2.513800 2.011100 2.144700 2.362658 1.941157 2.016350 1.191264 1.873540\n[49] 2.073400 1.547500 2.347471 2.230040 2.675983 2.360167 1.929983 2.036944\n[57] 2.221867 1.845379 1.949125 1.401186 1.813340 1.962100 1.630100 2.282443\n[65] 2.073940\n```\n\n\n:::\n:::\n\n\n\n# An example of \"untidy\" data\n\nPeople often make tables in short-wide format that end up not being tidy data. When people use column names to store data, it is no longer tidy. For example take a look at this built-in dataset that comes with `tidyr` on **religion and income survey data** with the number of respondents with income range in column name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\nrelig_income\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 11\n   religion `<$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n   <chr>      <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>      <dbl>\n 1 Agnostic      27        34        60        81        76       137        122\n 2 Atheist       12        27        37        52        35        70         73\n 3 Buddhist      27        21        30        34        33        58         62\n 4 Catholic     418       617       732       670       638      1116        949\n 5 Don’t k…      15        14        15        11        10        35         21\n 6 Evangel…     575       869      1064       982       881      1486        949\n 7 Hindu          1         9         7         9        11        34         47\n 8 Histori…     228       244       236       238       197       223        131\n 9 Jehovah…      20        27        24        24        21        30         15\n10 Jewish        19        19        25        25        30        95         69\n11 Mainlin…     289       495       619       655       651      1107        939\n12 Mormon        29        40        48        51        56       112         85\n13 Muslim         6         7         9        10         9        23         16\n14 Orthodox      13        17        23        32        32        47         38\n15 Other C…       9         7        11        13        13        14         18\n16 Other F…      20        33        40        46        49        63         46\n17 Other W…       5         2         3         4         2         7          3\n18 Unaffil…     217       299       374       365       341       528        407\n# ℹ 3 more variables: `$100-150k` <dbl>, `>150k` <dbl>,\n#   `Don't know/refused` <dbl>\n```\n\n\n:::\n:::\n\n\n\nTake a second to look at this data. In this case the variables are religion (a proper vector), income bracket (in the column names), and the number of respts, which is the third variable, is presented inside the table.\nonden\nConverting this data to tidy format would give us\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 180 × 3\n   religion income             respondents\n   <chr>    <chr>                    <dbl>\n 1 Agnostic <$10k                       27\n 2 Agnostic $10-20k                     34\n 3 Agnostic $20-30k                     60\n 4 Agnostic $30-40k                     81\n 5 Agnostic $40-50k                     76\n 6 Agnostic $50-75k                    137\n 7 Agnostic $75-100k                   122\n 8 Agnostic $100-150k                  109\n 9 Agnostic >150k                       84\n10 Agnostic Don't know/refused          96\n# ℹ 170 more rows\n```\n\n\n:::\n:::\n\n\n\nNow we have each variable along the columns and each row corresponds to one observation (or category, here a combination of religion and income bracket). \n\n# Reshaping data with `dplyr`\n\n### `pivot_longer()`\n\nThe `tidyr` package includes functions to transfer a data frame between *long* and *wide*.\n\n-   **Wide format** data has different attributes or variables describing an observation _placed in separate columns_.\n-   **Long format** data tends to have different attributes encoded as _levels_ of a single variable, followed by another column that contains _the values_ of the observation at those different levels.\n\n\nThe **key problem** with the tidyness of the original data is that the income variables are not in their own columns, but rather are embedded in the structure of the columns, making it hard to manipuate the income variables.\n\nTo **fix this**, you can use the `pivot_longer()` function to **gather values spread across several columns into a single column**, here with the column names gathered into an `income` column.\n\n\n### Mutate to convert character to factor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gather everything EXCEPT religion to tidy data\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\") %>%\n  mutate(religion = factor(religion), income = factor(income))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 180 × 3\n   religion income             respondents\n   <fct>    <fct>                    <dbl>\n 1 Agnostic <$10k                       27\n 2 Agnostic $10-20k                     34\n 3 Agnostic $20-30k                     60\n 4 Agnostic $30-40k                     81\n 5 Agnostic $40-50k                     76\n 6 Agnostic $50-75k                    137\n 7 Agnostic $75-100k                   122\n 8 Agnostic $100-150k                  109\n 9 Agnostic >150k                       84\n10 Agnostic Don't know/refused          96\n# ℹ 170 more rows\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-tip\n### Note\n-  When gathering, exclude any columns that you do not want \"gathered\" (`religion` in this case) by including the column names with a the __minus sign__ in the `pivot_longer()` function.\n-  Even if your data is in a tidy format, `pivot_longer()` is occasionally useful for pulling data together to take advantage of faceting, or plotting separate plots based on a grouping variable. \n:::\n\n### `pivot_wider()`\n\nThe `pivot_wider()` function is the opposite function. It is useful for creating summary tables for reports, but generally less commonly needed to tidy data. \n\nYou use the `summarize()` function in `dplyr` to summarize the total number of respondents per income category.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\") %>%\n  mutate(religion = factor(religion), income = factor(income)) %>% \n  group_by(income) %>% \n  summarize(total_respondents = sum(respondents)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   income             total_respondents\n   <fct>                          <dbl>\n 1 <$10k                           1930\n 2 >150k                           2608\n 3 $10-20k                         2781\n 4 $100-150k                       3197\n 5 $20-30k                         3357\n 6 $30-40k                         3302\n 7 $40-50k                         3085\n 8 $50-75k                         5185\n 9 $75-100k                        3990\n10 Don't know/refused              6121\n```\n\n\n:::\n:::\n\n\n\n`pivot_wider()` can be flexibly used in combination with __pivot_longer__ to make a nicer table to print.\n\nNotice in this example how `pivot_wider()` has been used at the **very end of the code sequence** to convert the summarized data into a shape that **offers a better tabular presentation for a report**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\") %>%\n  mutate(religion = factor(religion), income = factor(income)) %>% \n  group_by(income) %>% \n  summarize(total_respondents = sum(respondents)) %>%\n\n  pivot_wider(names_from = \"income\", \n              values_from = \"total_respondents\") %>%\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| <$10k| >150k| $10-20k| $100-150k| $20-30k| $30-40k| $40-50k| $50-75k| $75-100k| Don't know/refused|\n|-----:|-----:|-------:|---------:|-------:|-------:|-------:|-------:|--------:|------------------:|\n|  1930|  2608|    2781|      3197|    3357|    3302|    3085|    5185|     3990|               6121|\n\n\n:::\n:::\n\n\n\n\n\n::: callout-tip\n### Note\n\n-  In the `pivot_wider()` call, you first specify the name of the column to use for the new column names (`income` in this example) and then specify the column to use for the cell values (`total_respondents` here).\n-  Long format is often (but not always) the shape we need for tidy data. The important thing, however, is to __think carefully about the shape you need for your analysis__. \n:::\n\n::: callout-tip\n### Example of `pivot_longer()`\n\nLet's try another dataset. This data contain an excerpt of the [Gapminder data](https://cran.r-project.org/web/packages/gapminder/README.html#gapminder) on life expectancy, GDP per capita, and population by country.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\ngapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\nIf we wanted to make `lifeExp`, `pop` and `gdpPercap` (all measurements that we observe) go from a wide table into a long table, what would we do?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n```\n:::\n\n\n:::\n\n::: callout-tip\n### Example\n\nOne more! Try using `pivot_longer()` to convert the the following data that contains simulated revenues for three companies by quarter for years 2006 to 2009.\n\nAfterward, use `group_by()` and `summarize()` to calculate the average revenue for each company across all years and all quarters.\n\n**Bonus**: Calculate a mean revenue for each company AND each year (averaged across all 4 quarters).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  \"company\" = rep(1:3, each=4), \n  \"year\"  = rep(2006:2009, 3),\n  \"Q1\"    = sample(x = 0:100, size = 12),\n  \"Q2\"    = sample(x = 0:100, size = 12),\n  \"Q3\"    = sample(x = 0:100, size = 12),\n  \"Q4\"    = sample(x = 0:100, size = 12),\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 6\n   company  year    Q1    Q2    Q3    Q4\n     <int> <int> <int> <int> <int> <int>\n 1       1  2006    10    77    19    37\n 2       1  2007    48    35    89    44\n 3       1  2008    20    19    55    67\n 4       1  2009     0    81    20    29\n 5       2  2006    26    72    96    45\n 6       2  2007    31    16    23    11\n 7       2  2008    84    38    71    68\n 8       2  2009    59    58    93    75\n 9       3  2006    52    73    84    24\n10       3  2007     7   100    14     7\n11       3  2008    71    68    37    51\n12       3  2009     9    15    30    99\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself \n```\n:::\n\n\n:::\n\n### `separate()` and `unite()` cells within columns of data\n\nStill in the`tidyr` package:\n\n-   `unite()`: paste contents of two or more columns into a single column\n-   `separate()`: split contents of a column into two or more columns\n\nFirst, we combine the first three columns into one new column using `unite()`. This function is similar to `newvar <- paste(A,B,C, sep=\"_\")`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngapminder %>% \n  unite(col=\"country_continent_year\", \n        country:year, \n        sep=\"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 4\n   country_continent_year lifeExp      pop gdpPercap\n   <chr>                    <dbl>    <int>     <dbl>\n 1 Afghanistan_Asia_1952     28.8  8425333      779.\n 2 Afghanistan_Asia_1957     30.3  9240934      821.\n 3 Afghanistan_Asia_1962     32.0 10267083      853.\n 4 Afghanistan_Asia_1967     34.0 11537966      836.\n 5 Afghanistan_Asia_1972     36.1 13079460      740.\n 6 Afghanistan_Asia_1977     38.4 14880372      786.\n 7 Afghanistan_Asia_1982     39.9 12881816      978.\n 8 Afghanistan_Asia_1987     40.8 13867957      852.\n 9 Afghanistan_Asia_1992     41.7 16317921      649.\n10 Afghanistan_Asia_1997     41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\nNext, we show how to separate the columns into three separate columns using `separate()` using the `col`, `into` and `sep` arguments. Note that this works by finding the delimiter, and relies on order of the information. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  unite(col=\"country_continent_year\", \n        country:year, \n        sep=\"_\") %>% \n  separate(col=\"country_continent_year\", \n           into=c(\"country\", \"continent\", \"year\"), \n           sep=\"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent year  lifeExp      pop gdpPercap\n   <chr>       <chr>     <chr>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia      1952     28.8  8425333      779.\n 2 Afghanistan Asia      1957     30.3  9240934      821.\n 3 Afghanistan Asia      1962     32.0 10267083      853.\n 4 Afghanistan Asia      1967     34.0 11537966      836.\n 5 Afghanistan Asia      1972     36.1 13079460      740.\n 6 Afghanistan Asia      1977     38.4 14880372      786.\n 7 Afghanistan Asia      1982     39.9 12881816      978.\n 8 Afghanistan Asia      1987     40.8 13867957      852.\n 9 Afghanistan Asia      1992     41.7 16317921      649.\n10 Afghanistan Asia      1997     41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Using prose, describe how the variables and observations are organised in a tidy dataset versus an non-tidy dataset.\n\n2.  What do the extra and fill arguments do in `separate()`? Experiment with the various options for the following two toy datasets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n```\n:::\n\n\n\n3.  Both `unite()` and `separate()` have a remove argument. What does it do? Why would you set it to FALSE?\n\n4.  Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one `unite()`?\n:::\n\n### Solution for gapminder example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  pivot_longer(-c(country, continent, year), names_to = \"metrics\", values_to = \"values\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,112 × 5\n   country     continent  year metrics       values\n   <fct>       <fct>     <int> <chr>          <dbl>\n 1 Afghanistan Asia       1952 lifeExp         28.8\n 2 Afghanistan Asia       1952 pop        8425333  \n 3 Afghanistan Asia       1952 gdpPercap      779. \n 4 Afghanistan Asia       1957 lifeExp         30.3\n 5 Afghanistan Asia       1957 pop        9240934  \n 6 Afghanistan Asia       1957 gdpPercap      821. \n 7 Afghanistan Asia       1962 lifeExp         32.0\n 8 Afghanistan Asia       1962 pop       10267083  \n 9 Afghanistan Asia       1962 gdpPercap      853. \n10 Afghanistan Asia       1967 lifeExp         34.0\n# ℹ 5,102 more rows\n```\n\n\n:::\n:::\n\n\n\nWe stacked the three variables `lifeExp`, `pop`, and `gdpPercap` so now the table is a little thinner and three times as long. \n\nWhy did we have to make the non-gathered variables into a vector? \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}