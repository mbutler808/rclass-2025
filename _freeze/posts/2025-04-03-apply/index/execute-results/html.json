{
  "hash": "28174b75629586f3694628ec9c5e9c3c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectorization with Apply Functions\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Apply functions can help with vectorization and scaling up\"\ndate: 2023-03-23\ncategories: [module 5, week 10, apply, lists, for loops, programming]\n---\n\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Recognize the different types of apply functions\n-   Be able to use apply functions to perform operations on objects\n-   Be introduced to writing functions for apply functions\n-   Have gained another skill in modular programming\n:::\n\n# Overview\n\nRepeated execution on a number of objects is a common task you will have to do. For example, when you want a bootstrap confidence interval on something youʻve estimated, you will run the analysis once, on the original data, and on 100 or 1000 samples of simulated data. \n\nWhen you know how many times you want to repeat execution, two common methods are to use `for loops` and `apply` functions. `apply()` functions are special functions that operate on lists, and come in different flavors depending on the type of object you want returned. \n\n\n# Vectorized computations\n\nMany functions in R are already vectorized in that they will perform the same computation on the entire object (rather than element by element). Basic arithmetic on vectors is a good example. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\ny <- 10\nz <- x + y\nz \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13 14 15\n```\n\n\n:::\n:::\n\n\n\nThe two vectors, x and y, are added together in parallel because vector arithmetic is vectorized.  This allows you to write code that is natural, fast, and easy to read. \n\nIf R were not vectorized (as in Fortran and C), you would have to code operations element by element like so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- numeric(length(x))\n\nfor(i in seq_along(x)) {  # seq_along(x) same as 1:length(x) \n      z[i] <- x[i] + y\n}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13 14 15\n```\n\n\n:::\n:::\n\n\n\nImagine if you had to do this each time you wanted to do anything to any objects!  It would take a lot longer to get anything done.  _Vectorization makes coding much more natural._ \n\nWhen you do find operations that are not vectorized, you can use `apply` functions (below).  But before we get into that, letʻs build up our example with a loop. \n\n# Loops\n\n`for` loops are straightforward to understand, and are a general feature of every programming language. They are necessary at times, for example when you need the results of the previous iteration for the current one. But they are usually slower in R and sometimes not very elegant (making the code harder to understand). For example, think of a very simple function that calculates the square of a number:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function( x ) {\n  return (x*x)\n  }\n```\n:::\n\n\n\nIf you wanted to apply it to the vector 1:10, using a for loop, it would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- vector(length=10)   ## create a container for output\n\nfor ( i in 1:10 ) {       ## step through i from 1 to 10\n  xx[i] <- square( i )    ## run square function for each i\n}\n\nxx  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\n\nThis runs the `square()` function 10 times, once for each value of `i` from 1 to 10. Importantly, notice that it works by going through `i` one element at a time.  \n\n\n# Apply Functions\n\nAnother way to repeatedly execute code is via the `apply()` functions. `apply` functions are unique to R, and in some situations can operate on an entire object at once, which can make them fast. This is called **vectorization**. \n\nLetʻs try `sapply()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply( 1:10, square ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\n\nThere are several different _flavors_ of apply functions, but they all have similar forms:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply( X, FUN, ...)\n```\n:::\n\n\n\nWhere `X` is an object, and `FUN` is a function. The function is applied to each element of `X`, often simultaneously (whether this happens simultaneously or not depends on whether the function written with vectorization in mind, you have to just try). \n\n## `sapply` and `lapply`\n\nAnother common type is `lapply`, which operates on list objects and returns a list.  `sapply` (`s` for simplify) is almost identical to `lapply`, but tries to make prettier output by returning a vector or a matrix if possible (instead of a list):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply( 1:5, square ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n\n```{.r .cell-code}\nlapply( 1:5, square )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 16\n\n[[5]]\n[1] 25\n```\n\n\n:::\n:::\n\n\n\n- There is also `apply()` which works on matrices or arrays, and has an index argument for whether it should apply the function over rows or columns.  \n\n- `tapply` to apply the function across a grouping index or treatments. \n\n- `mapply` to apply to multiple lists simultaneously.\n\n- `outer` which applies the function to an outer product of two arrays, and more. \n\n- `aggregate` is actually a user-friendly wrapper for `tapply`, used to apply a function across groups. \n\nAll of the `apply` functions work in the same way. Donʻt get overwhelmed - I mainly use `sapply` or `lapply`, and `aggregate`, and occasionally `apply` if I need to work over rows.  Thatʻs all you need to remember, consult the help page when you need. \n\n# Example of calculating summary statistics using aggregate and merge\n\nLetʻs calculate the mean and standard error of sexual size dimorphism (log(male size/female size)) in _Anolis_ lizards, and make a nice table:\n\nThe data are included in the GitHub repo for this course. There are 23 species, with each species belonging to one of five ecomorph groups. We can aggregate by mean over ecomorph groups:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanolis <- read.csv(\"https://raw.githubusercontent.com/mbutler808/rclass/main/data/anolisSSD.csv\")\n\naggregate(anolis$logSSD, by=list(anolis$ecomorph), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Group.1         x\n1  crown-giant 0.1391750\n2   grass-bush 0.1437525\n3        trunk 0.1467167\n4  trunk-crown 0.2626575\n5 trunk-ground 0.3339650\n6         twig 0.0848450\n```\n\n\n:::\n:::\n\n\n\nCalculate the mean and the sd by ecomorph group, and this time save them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanolis.mean <- aggregate(anolis$logSSD, by=list(anolis$ecomorph), mean)\nanolis.sd <- aggregate(anolis$logSSD, by=list(anolis$ecomorph), sd)\nanolis.sd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Group.1          x\n1  crown-giant 0.09909567\n2   grass-bush 0.06924584\n3        trunk 0.02136480\n4  trunk-crown 0.09968872\n5 trunk-ground 0.06966130\n6         twig 0.07107131\n```\n\n\n:::\n:::\n\n\n\nGive the results of aggregate meaningful column names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(anolis.mean)   # check that this is what we want to modify\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Group.1\" \"x\"      \n```\n\n\n:::\n\n```{.r .cell-code}\nnames(anolis.mean) <- c(\"ecomorph\", \"mean\")\nnames(anolis.sd) <- c(\"ecomorph\", \"sd\")\n```\n:::\n\n\nWhile we’re at it, let’s get the sample size so that we can calculate the standard error, which is the standard deviation divided by the square root of the sample size.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanolis.N <- aggregate(anolis$logSSD, by=list(anolis$ecomorph), length)\nnames(anolis.N) <- c(\"ecomorph\", \"N\")\n```\n:::\n\n\n\nTo put the columns together, use `merge()`. Here there is only one matching column (ecomorph), so the `by=` is optional, but itʻs good practice:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- merge(anolis.mean, anolis.sd, by=\"ecomorph\")\nout <- merge(out, anolis.N, by=\"ecomorph\")\n```\n:::\n\n\n\nMerging works two by two so we have to do it a second time to add the `N`. There are also options for `by.x=` and `by.y=` in case your columns have different names in the two objects – you can tell R which two columns to match.\n\nNow itʻs easy to add the standard error, and we can use the `print()` function to reduce the number of digits displayed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout$se <- out$sd / sqrt(out$N)\nprint(out, digits=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      ecomorph  mean    sd N    se\n1  crown-giant 0.139 0.099 4 0.050\n2   grass-bush 0.144 0.069 4 0.035\n3        trunk 0.147 0.021 3 0.012\n4  trunk-crown 0.263 0.100 4 0.050\n5 trunk-ground 0.334 0.070 4 0.035\n6         twig 0.085 0.071 4 0.036\n```\n\n\n:::\n:::\n\n\n\nOr rearrange for our paper format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- out[c(\"ecomorph\", \"N\", \"mean\", \"se\")]\nprint(out, digits=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      ecomorph N  mean    se\n1  crown-giant 4 0.139 0.050\n2   grass-bush 4 0.144 0.035\n3        trunk 3 0.147 0.012\n4  trunk-crown 4 0.263 0.050\n5 trunk-ground 4 0.334 0.035\n6         twig 4 0.085 0.036\n```\n\n\n:::\n:::\n\n\n\nWe can save it for later as well:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(out, \"anolis.summary.csv\", row.names=FALSE)\nsaveRDS(out, \"anolis.summmary.rds\")\n```\n:::\n\n\n# Additional Arguments to `apply` functions\n\nIf the function needs additional arguments, you just provide them separated by commas: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply( X, FUN, arg1, arg2, ...)\n```\n:::\n\n\n\nFor example, letʻs say we wanted to sample with replacement from the vector `1:5`. To do it once, we would do:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(5, replace=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 3 1 3 1\n```\n\n\n:::\n:::\n\n\n\nTo do it 4 times, you could do: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply( c(5, 5, 5, 5), sample, replace=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    4    3    4    5\n[2,]    5    3    1    5\n[3,]    3    1    3    1\n[4,]    1    5    2    3\n[5,]    4    4    4    5\n```\n\n\n:::\n:::\n\n\n\n`sapply` took the vector of fives and created a sample for each one. \n\n# Using homemade functions\n\nSometimes the function that you want to run inside of an apply function is more complicated and requires many lines. Suppose you wanted to run several functions or have many lines of code.  You have two choices.  First, you can write a function definition and then pass it to an apply function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfunction <- function (file, y=NULL, z=NULL) {\n  xx <- read.csv(file)\n  plot(xx, ...) \n  zz <- some_other_function (x,y,z)\n  ... \n  return (out)\n  }\nsapply(  list_of_filenames ,  myfunction, y=blah1, z=blah2) \n```\n:::\n\n\n\nAlternatively you could  define the function within the apply function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply( input, function(x) {\n  ...lines_of_code... \n  })\n```\n:::\n\n\n\nWhere `x` is a single element of the `input` object, so if `input` is a vector, `x` would be one element of the vector.  But if `input` is a list, it would be the first list element, etc. Apply functions work really nicely with lists, and many times they handle dataframes nicely as well.   \n\nTo return to one of our first examples, to code the `square` function inside of the `sapply` it would simply be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply ( 1:10, function(x)  x*x )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\n Where `{}` around `{x*x}` are optional here because itʻs only one line.  This is much cleaner and more elegant than:\n \n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- vector(length=10)   ## create a container for output\n\nfor ( i in 1:10 ) {       ## step through i`s from 1 to 10\n  xx[i] <- square( i )    ## run square function for each i\n  }\n\nxx  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\n\nFurthermore, itʻs often easier to understand assigning the output object, because the entire object is returned, not filled element by element:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- sapply ( 1:10, function(x)  x*x )\n```\n:::\n\n\n\nThis is another advantage of thinking of the manipulation on the whole object rather than pieces of it. \n\n\n## Exercises\n\n1.  Perform the following computation using an apply function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- vector(\"list\")   ## creates a null (empty) list\nfor (i in 1:4) {\n   mylist[i] <- list(data.frame(x=rnorm(3), y=rnorm(3)))  \n}\n```\n:::\n\n\n2. Plot `x` as a function of `y` for each dataframe using an apply function. \n3.  Using an apply function, compute an anova on `x ~ y` on each dataframe, and save the anova output (there should be 4 of them) to a list or dataframe. \n4.  Write a for loop that finds the sum of the sequence of integers from 1 to 100, then accomplish the same computation with an apply function.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}