{
  "hash": "c0e147edc02a02ad4e95aed93b31c48e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The ggplot2 package\"  \nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Introduction to the gplot2 grammar of graphics\"  \ndate: 2025-02-25\ncategories: [module 3, week 7, R, programming, plotting, ggplot2, data visualization]  \n---\n\n\n\n<!-- R emoji aliases:  https://gist.github.com/rxaviers/7360908 -->\n<!-- NA -->\n\n\n### Excellent references\n\n::: callout-note\n## For more details see\n\n1.  Wonderful Window shopping in the R graph gallery (with code): <https://r-graph-gallery.com>\n2.  The \"grammar of graphics\" explained in Hadley Wickamʻs article: <http://vita.had.co.nz/papers/layered-grammar.pdf>\n3.  Very gentle intro for beginners: <https://posit.cloud/learn/primers/3>\n4.  Hadley Wickamʻs overview: <https://r4ds.had.co.nz/data-visualisation>\n4.  Cedric Schererʻs Step-by-step tutorial: <https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/>\n6.  For in-depth reading, Hadley Wickamʻs ggplot2 book: <https://ggplot2-book.org>\n:::\n\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <http://rafalab.dfci.harvard.edu/dsbook/ggplot2.html>\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-15-ggplot2-plotting-system-part-2/> \n-   <https://rdpeng.github.io/Biostat776/lecture-the-ggplot2-plotting-system-part-2>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to build up layers of graphics using `ggplot()`\n-   Be able to modify properties of a `ggplot()` including layers and labels\n:::\n\n\n# Overview \n\nLast time we discussed the elements of plotting in the R base graphical system. The base functions such as `plot()` open a new plot window and set up the coordinate system, axes, and often return the default plot. Annotations can be added onto a plot with additional functions such as `points()`, `lines()`, `text()`, etc. Many other plotting functions exist too, you can check out the `graphics` package <https://rdocumentation.org/packages/graphics/versions/3.6.2>. Or type `?graphics` at the R prompt and check out the help page index. \n\nToday we will learn about the [`ggplot2` package](https://ggplot2.tidyverse.org) written by Hadley Wickam <https://hadley.nz>. `ggplot2` introduces a new syntax for plotting, based on the idea of a *grammar of graphics*. The idea is that the user supplies the data, specifies how ggplot2 maps variables to aesthetics, what graphical primitives or types to use, and it takes care of the details. The grammar of graphics builds plots in layers. \n\nJust as in spoken language, where a beginner can form many sentences from only learning a handful of verbs, nouns and adjectives, using the ggplot2 grammar, even beginners can create hundreds of different plots.\n\nNote that `ggplot2` is part of the `tidyverse` and thus is designed to work exclusively with data tables in tidy format (rectangular data where rows are observations and columns are variables). \n\nBeing literate in ggplot2 requires using several functions and arguments, which may not make sense at first. The ggplot2 cheat sheet can be super helpful: <https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf> or google “ggplot2 cheat sheet”.\n\n\nThe first step in learning `ggplot2` is to understand the basic elements of the grammar:\n\n## Basic components of a ggplot2 plot\n\n::: callout-tip\n### Key components\n\nA **`ggplot2` plot** consists of a number of **key components**.\n\n-  __Data__: In the form of a dataframe or tibble, containing all of the data that will be displayed on the plot.\n-  __Geometry__: The geometry or `geoms` define the style of the plot such as scatterplot, barplot, histogram, violin plots, smooth densities, qqplot,  boxplot, and others. \n- __Aesthetic mapping__: Aesthetic mappings describe how data are mapped to color, size, shape, location, or to legend elements. How we define the mapping depends on what geometry we are using.\n\nNearly all plots drawn with ggplot2 will have the above compoents. In addition you may want to have specify __additional elements__: \n\n-  __Facets__: When used, facets describe how panel plots based on partions of the data should be drawn.\n\n-   __Statistical Transformations__: Or __stats__ are transformations of the data such as log-transformation, binning, quantiles, smoothing.\n\n-   __Scales__: Scales are used to indicate which factors are associated with the levels of the aesthetic mapping. Use manual scales to specify each level. \n\n-   __Coordinate System__: ggplot2 will use a default coordinate system drawn from the data, but you can customize the coordinate system in which the locations of the geoms will be drawn\n\n:::\n\n\nPlots are built up in layers, with the typical ordering being\n\n1.  Plot the data\n2.  Overlay a summary that reveals the relationship\n3.  Add metadata and annotation\n\n\n# Creating a ggplot object\n\n`ggplot2` works by creating a ggplot object that can you can then add to. The `ggplot()` function initializes the graph object, usually by specifying the data. See the `?ggplot` help page. \n\nWeʻll start by loading the ggplot package and using the built-in `iris` dataset. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(ggplot2) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggplot2\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = iris)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\nAnother way to send data to the function is through piping. These are both equivalent to the line above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> ggplot()\niris %>% ggplot()\n```\n:::\n\n\n\nThe `%>%` is the older pipe operator, but you will start to see `|>` more often now too. \n\nYou have sent data to  `ggplot()` but it is a blank canvas because you have given it no geometry to plot (no points, bars, etc.)\n\nIt is an object, so you can save it to a named variable, say `p`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(data = iris)\nclass(p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"gg\"     \"ggplot\"\n```\n\n\n:::\n:::\n\n\n\nTo render the plot associated with this object, we simply print the object p. We can do this in interactive mode by simply typing `p` at the command line or using the `print()` function. However, in a script, you will want to use the `print()` function, and typically print it to a pdf device. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(p)\np\n\npdf()       # opens a pdf device\n  print(p)  # prints the plot\ndev.off()   # closes pdf device\n```\n:::\n\n\n\n# Layers\n\nAdditional components are added in layers, which is to say, separate R statements added on to the object with the `+` operator. Layers are very flexible and can define geometries, compute summary statistics, define what scales to use, or even change styles. \n\nA template for creating a plot with layers would look like this:\n\n> DATA |> ggplot() + LAYER1 + LAYER2 + … + LAYERN\n\nTo save it to a ggplot object, say `p`: \n\n> p <- DATA |> ggplot() + LAYER1 + LAYER2\n\nOr if you want to save different varieties of objects or at different stages, just assign them to different names:\n\n> q <- p + LAYER3  \n> r <- p + LAYER4 \n\n\n# Geometries\n\n\nThe geometry specifies the geometrical elements such as points, lines, etc. which in turn determines the kind of plot that we want to make. If We want to make a scatterplot. What geometry do we use?\n\nTaking a quick look at the [cheat sheet](https://posit.co/resources/cheatsheets/), we see that the function used to create plots with this geometry is `geom_point`.\n\n![](https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf)\n\n\nIt will take you a bit to get familiar with the naming conventions, but with them you can use some powerful tools. \n\nGeometry function names follow the pattern: geom_ followed by the name of the geometry. Some examples include `geom_point`, `geom_bar`, and `geom_histogram`.\n\nFor `geom_point` to run properly we need to provide __data__ and a __mapping__. We have already connected the object p with the iris data table, and if we add the layer `geom_point` it defaults to using this data. \n\nTo find out what mappings are expected, jump down to the __Aesthetics section__ of the help file `geom_point` help file. It states that the required aesthetics are in bold. Which arguments are required? \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?geom_point\n```\n:::\n\n\n\nIt should come as no surprise that to make points appear, you need to specify `x` and `y`. \n\n\n# Aesthetic mappings\n\n__Aesthetic mappings__ connect elements of the data with features of the graph, such as distance along an axis, size, or color. \n\nThe `aes()` function, used inside of a __geom__ is where the mappings happen, that is where data are connected with graph elements through defining __aesthetic mappings__ (you will see this lingo a lot).\n\nTo produce a scatterplot of `Petal.Length` by `Petal.Width` we could use:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> ggplot() + \n  geom_point(aes(x = Petal.Length, y = Petal.Width))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nWe can drop the x = and y = if we wanted to since these are the first and second expected arguments, as seen in the help page.\n\nInstead of defining our plot from scratch, if we save the object as `p` we can also add a layer to the `p` object. The lines below produce the same plot (verify yourself):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(data = iris)\np + geom_point(aes(Petal.Length, Petal.Width))\n```\n:::\n\n\n\nNothing else was specified, so the __scale__ and __labels__ are defined by default when adding this layer. __aes__ uses the variable names from the vectors within the data object: we donʻt have to call them as `iris$Petal.Length` and `iris$Petal.Width`. \n\nThe behavior of recognizing the variables from the data component is quite specific to __aes__. With most functions, if you try to access the values of Petal.Length outside of aes you receive an error.\n\n# Adding annotations (more layers)\n\nSuppose we wanted to label each point on the plot. First we add numbers to the iris data and remake the ggplot object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris$id <- c(1:length(iris$Species)) \nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species id\n1          5.1         3.5          1.4         0.2  setosa  1\n2          4.9         3.0          1.4         0.2  setosa  2\n3          4.7         3.2          1.3         0.2  setosa  3\n4          4.6         3.1          1.5         0.2  setosa  4\n5          5.0         3.6          1.4         0.2  setosa  5\n6          5.4         3.9          1.7         0.4  setosa  6\n```\n\n\n:::\n:::\n\n\n\nThe `geom_label` and `geom_text` functions  add text to the plot with and without a rectangle behind the text, respectively.\n\nBecause each point has a label (id), we need an aesthetic mapping to make the connection between points and labels. By reading the help file, we learn that we supply the mapping between point and label through the label argument of aes. So the code looks like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- iris |> ggplot() + \n  geom_point(aes(Petal.Length, Petal.Width)) +\n  geom_text(aes(Petal.Length, Petal.Width, label = id))\np  \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nItʻs a mess because there are many identical points, but you can see how it works.\n\nPay special attention to what goes __inside__ and __outside__ of the `aes()`. \n\n\nNote:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_test <- p + geom_text(aes(Petal.Length, Petal.Width, label = id))\n```\n:::\n\n\n\nWorks, but moving `label=id `outside of the `aes()` does not: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_test <- p + geom_text(aes(Petal.Length, Petal.Width), label = id)\n```\n:::\n\n\n\nThe variable `id` is only understood to be part of the original dataframe inside of `aes()`. More on this later.\n\n# Global versus local aesthetic mappings\n\nIn the previous example, we define the mapping `aes(Petal.Length, Petal.Width)` twice, once in each geometry. \n\nIf the same mapping applies to each component of the plot, we can use a __global aesthetic mapping__. Generally we do this when we define the blank slate ggplot object. Remember that the function ggplot contains an argument that permits us to define aesthetic mappings:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(ggplot)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (data = NULL, mapping = aes(), ..., environment = parent.frame()) \nNULL\n```\n\n\n:::\n:::\n\n\n\nIf we define a mapping in ggplot, all the geometries that are added as layers will default to this mapping. We redefine p:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- iris |> ggplot(aes(Petal.Length, Petal.Width, label=id)) \n```\n:::\n\n\n\nand then we can simply write the following code to produce the previous plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(size = 3) + \n  geom_text(nudge_x = .15)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nWe keep the size and nudge_x arguments in geom_point and geom_text, respectively, because we want to only increase the size of points and only nudge the labels. If we put those arguments in aes then they would apply to both plots. Also note that the geom_point function does not need a label argument and therefore ignores that aesthetic.\n\nIf necessary, we can override the global mapping by defining a new mapping within each layer. These local definitions override the global. Here is an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(size = 3) +  \n  geom_text(aes(x = 2, y = 2, label = \"Hello there!\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_text(aes(x = 2, y = 2, label = \"Hello there!\")): All aesthetics have length 1, but the data has 150 rows.\nℹ Please consider using `annotate()` or provide this layer with data containing\n  a single row.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nClearly, the second call to geom_text does not use population and total.\n\n\n\n# Scales\n\nChanging scales is a common task. For example, in morphometrics, we often use a log scale. We can log transform the plot (how it looks without changing the data) through a scales layer. A quick look at the cheat sheet reveals the __scale_x_continuous__ function lets us control the behavior of scales. We use them like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(size = 3) +  \n  geom_text(nudge_x = 0.05) + \n  scale_x_continuous(trans = \"log10\") +\n  scale_y_continuous(trans = \"log10\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nBecause we are in the log-scale now, the nudge must be made smaller.\n\nThis particular transformation is so common that ggplot2 provides the special functions __scale_x_log10__ and __scale_y_log10__:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(size = 3) +  \n  geom_text(nudge_x = 0.05) + \n  scale_x_log10() +\n  scale_y_log10() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# Labels and titles\n\nSimilarly, the cheat sheet shows that to change labels and add a title, we use the following functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <- p + geom_point(size = 3) +  \n  geom_text(nudge_x = 0.05) + \n  scale_x_log10() +\n  scale_y_log10() +\n  xlab(\"Petal Length (log scale)\") + \n  ylab(\"Petal Width (log scale)\") +\n  ggtitle(\"Fisherʻs Iris dataset\")\n```\n:::\n\n\n\nWe are almost there! All we have left to do is add color, a legend, and optional changes to the style.\n\n# Color annotations by group\n\nWe can change the color of the points using the `col` argument in the `geom_point()` function. To facilitate demonstration of new features, we will save the log-scaled plot as q and include everything except the points layer:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq + geom_point(size = 3, color =\"blue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nThis, of course, is not what we want. We want to assign color depending on the Species. A nice default behavior of ggplot2 is that if we assign a categorical variable to color, it automatically assigns a different color to each category and also adds a legend.\n\nSince the choice of color is determined by a feature of each observation, this is an aesthetic mapping. To map each point to a color, we need to use aes. We use the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq + geom_point(aes(col=Species), size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nWhy donʻt we need to supply the x and y? Those mappings are inherited from the global aes specification in __p__. \n\nSuppose we wanted to use a custom color palette for our data. How do we specify them? Notice that the __aes(col=Species)__ indicates which __points__ are grouped by color according to the __Species__ value. _Nothing in the vector Species indicates a color._  \n\nRecall that Species is actually a __factor__, and so the values would be 1,2,3. How does this information get translated? In R, numbers are translated into a default color vector for plot. \n\n### Specifying custom colors\n\nThe values of the colors we wish to use are specified in the scale parameter __scale_color_manual__. For these examples, letʻs go back to the untransformed values: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species, size = 3)) +\n  scale_color_manual(values=c(\"red\", \"blue\", \"purple\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nR has hundreds of named colors. You can see the names with the `colors()` function. There is a cool little function in the __easyGgplot2__ package that displays the colors. Now we have a lot of fancy colors to play with:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")\nremotes::install_github(\"kassambara/easyGgplot2\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neasyGgplot2::showCols()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n### Specifying colors by level\n\nWe can control which color is matched with which level of species. Looking at the help page for __scale_color_manual__, under *values* we see the explanation:\n\n> __values__  \n> a set of aesthetic values to map data values to. The values will be matched in order (usually alphabetical) with the limits of the scale, or with breaks if provided. If this is a __named vector__, then the _values will be matched based on the names instead_. Data values that don't match will be given na.value. \n\nLetʻs use some of these fun colors, by creating a vector `cols` of color names and passing it to the `values` argument of `scale_color_manual`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"darkorange\", \"navyblue\", \"deeppink\")\n\np + geom_point(aes(col=Species, size = 3)) +\n  scale_color_manual(values=cols)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\nThis is great! But what if we wanted to have pink on the bottom (setosa), orange in the middle (versicolor), and navy (virginica) on the top? \nPlaying with the vector by trial and error always works, but what if we had a dozen species? \n\n### Named color vector\n\nWe can specify the match of colors to specific species by naming the `cols` vector with the species names. Then the `cols` vector will have color values, named by the species they represent: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"darkorange\", \"navyblue\", \"deeppink\")\nnames(cols) <- c(\"versicolor\", \"virginica\", \"setosa\")\n\np + geom_point(aes(col=Species, size = 3)) +\n  scale_color_manual(values=cols)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\nVoila! `names(cols)` and `cols` are a perfect example of a key - value pair. \n\n### Transparency\n\nThe transparency of colors is controlled by the aesthetic `alpha`, where 1 indicates 100% opacity (or 0 transparency), with smaller decimals indicating more transparency.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species, size = 3, alpha = 0.5)) +\n  scale_color_manual(values=cols)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nTransparency really helps with overlapping points. \n\n### Jitter\n\nAnother way of dealing with overlapping points is to add a little random noise to each, called __jitter__. Try using `geom_jitter` instead of `geom_point`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_jitter(aes(col=Species, size = 3, alpha = 0.5)) +\n  scale_color_manual(values=cols)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\nIf you want to see where the jitter is relative to the true coordinates, you can use both:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point() +\n  scale_color_manual(values=cols) +\n  geom_jitter(aes(col=Species, size = 3, alpha = 0.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\nHere the true points are in color, and the jitter is shown in the smaller black points. \n\nJitter is fine for discrete values to spread it out for visualization (say jitter along the discrete axis but not the continuous axis), _but not as ideal for metric data where distance along the axis really mean something_. \n\n# Side by side plots\n\nFacets work great when they are subsets of the same data, but when you have different data or you want to apply different geoms or aesthetics and compare, you need a more general purpose panel system.  \n\nThe `cowplot` package was written for arranging multiple plots. Letʻs compare what it looks like to jitter the black dots vs. jittering the transparent circles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"cowplot\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(cowplot)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: cowplot\n```\n\n\n:::\n\n```{.r .cell-code}\nplot1 <- p + geom_point() +\n  scale_color_manual(values=cols) +\n  geom_jitter(aes(col=Species, size = 3, alpha = 0.5))\n\nplot2 <- p + geom_point(aes(col=Species, size = 3, alpha = 0.5)) +\n  scale_color_manual(values=cols) +\n  geom_jitter()\n  \nplot_grid(plot1, plot2, labels=\"AUTO\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\nThe labels arguement is to label the plots, for example for publication. \n\nAnother example, suppose we want to explore variation along `Sepal.Length` by `Species`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot1 <- ggplot(iris, aes(x = Species, y = Sepal.Length, fill=Species)) + \n  geom_boxplot() +\n  scale_color_manual(values=cols,  aesthetics=\"fill\") \n \nplot2 <- ggplot(iris, aes(x = Sepal.Length, fill = Species, col=Species)) + \n  geom_density(alpha=0.5) +\n  scale_color_manual(values=cols, aesthetics=\"fill\") +\n  theme(legend.position = c(0.8, 0.8))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n3.5.0.\nℹ Please use the `legend.position.inside` argument of `theme()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nplot_grid(plot1, plot2, labels=\"AUTO\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\nThis is not quite right - we need to fix it! Please check the help pages. \n\n# Annotation, shapes, and adjustments\n\nWe often want to add shapes or annotation to figures that are not derived directly from the aesthetic mapping; examples include labels, boxes, shaded areas, and lines.\n\n\n### Scatterplot with smoother\n\n__geom_smooth()__ adds a smoothing line but the default is a __loess__ smoother, which is flexible and nonparametric but might be too flexible for our purposes. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) +\n    geom_smooth()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The following aesthetics were dropped during statistical transformation: label.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n\nWe get a warning because we are not using the `label` aesthetic (remember it is =id). There is no problem but to stop the annoying warnings, letʻs leave off `label` until we need it. \n\nIf we want to explain a simple linear trend between the `x` and `y` variables, perhaps we’d prefer a linear regression line.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- iris |> ggplot(aes(x = Petal.Length, y = Petal.Width))\n\np + geom_point(aes(col=Species), size = 3) +\n    geom_smooth(method=\"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n\nOr without the standard error envelope:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) +\n    geom_smooth(method=\"lm\", se=FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\nWe can also compute the regression separately and add the line using `geom_abline()`, similar to the base R `abline()` function. Note: the ab in the name is to remind us we are supplying the intercept (a) and slope (b). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit <- lm(iris$Petal.Width ~ iris$Petal.Length)\n\np + geom_point(aes(col=Species), size = 3) +\n    geom_abline(intercept = coef(lm.fit)[1], slope= coef(lm.fit)[2])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\nHere `geom_abline()` does not use any information from the data object, only the regression coefficients.\n\nWe can change the line type and color of the lines using arguments. Also, we draw it first so it doesn’t go over our points.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_abline(intercept = coef(lm.fit)[1], \n                slope= coef(lm.fit)[2],\n                lty = 2, \n                color = \"darkgrey\") +\n  geom_point(aes(col=Species), size = 3)  \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n\n### __geom___ by group\n\nWe can see that although the three species of iris generally fall along a line, that there are clusters by species. Perhaps separate linear models by group may be a better fit. \n\nThere are two ways that we can do this. The first is to put a grouping aesthetic within the smoother. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) +\n    geom_smooth( aes(group=Species), method=\"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n\nAnother way to do this is to add col (here as a grouping variable) in the global ggplot aesthetic, which will apply to all downstream layers: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- iris |> ggplot(aes(x = Petal.Length, y= Petal.Width, col=Species)) \n \nr + geom_point(aes(col=Species), size = 3) +\n    geom_smooth( method=\"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n\n### Multi panel plots __facet_wrap__\n\n[Facets](https://ggplot2-book.org/facet.html) are what ggplot calls multi-panel plots. They split the data by some factor, which can be very helpful for viewing varition of subsets of the data. \n\nThe two main functions are `facet_wrap()` and `facet_grid()`\n\n__facet_wrap()__ lays the panels out in a ribbon, in sequential order. See the documentation for arguments to control the number of rows or columns, etc. \n\nThe faceting variable (here, Species) is using formula syntax `~Species`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) +\n   geom_smooth( method=\"lm\") + \n   facet_wrap(~Species)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n\n__facet_grid()__ is explicity a grid. The syntax `. ~ Species` facets by column. a\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) +\n   geom_smooth( method=\"lm\") + \n   facet_grid(. ~ Species)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n\nThe syntax `Species ~ .` facets by row. The syntax `Y ~ X` would facet by rows and columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) +\n   geom_smooth( method=\"lm\") + \n   facet_grid(Species ~ .)   \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n\n\n# More customization\n\nThe default plots created by ggplot2 are already very useful. However, we frequently need to make minor tweaks to the default behavior. Although it is not always obvious how to make these even with the cheat sheet, ggplot2 is very flexible.\n\n## Legend\n\nFor example, we can make changes to the legend title via the `scale_color_discrete function()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3) + \n  scale_color_discrete(name = \"Iris Varieties\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n\n## No legend\n\nggplot2 automatically adds a legend that maps color to species. To remove the legend we set the `geom_point()` argument `show.legend = FALSE`.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + geom_point(aes(col=Species), size = 3, show.legend=FALSE)\n```\n:::\n\n\n\n## Themes\n\nThe **default theme for `ggplot2` uses the gray background** with white grid lines.\n\nIf you don't like this, you can use the black and white theme by using the `theme_bw()` function.\n\nThe `theme_bw()` function also allows you to set the typeface for the plot, in case you don't want the default Helvetica. Here we change the typeface to Times.\n\n::: callout-tip\n### Note\n\nFor things that only make sense globally, use `theme()`, i.e. `theme(legend.position = \"none\")`. Two standard appearance themes are included\n\n-   `theme_gray()`: The default theme (gray background)\n-   `theme_bw()`: More stark/plain\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + \n  geom_point(aes(color = Species)) + \n  theme_bw(base_family = \"Times\")\n```\n\n::: {.cell-output-display}\n![Modifying the theme for a plot](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n\n\n# Add-on packages\n\nThe power of ggplot2 is augmented further due to the availability of add-on packages. The remaining changes needed to put the finishing touches on our plot require the `ggthemes` and `ggrepel` packages.\n\n## __ggthemes__\n\nThe style of a ggplot2 graph can be changed using the theme functions. Several themes are included as part of the ggplot2 package. \n\nMany other themes are added by the package `ggthemes`. Among those are the `theme_economist` theme that we used. After installing the package, you can change the style by adding a layer like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(ggthemes)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggthemes\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'ggthemes'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:cowplot':\n\n    theme_map\n```\n\n\n:::\n\n```{.r .cell-code}\np + geom_point(aes(col=Species, size = 3, alpha = 1/2)) +\n  scale_color_manual(values=cols) + \n  theme_economist()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\nYou can see how some of the other themes look by simply changing the function. For instance, you might try the `theme_fivethirtyeight()` theme instead.\n\n__ggrepel__\n\nThe final difference has to do with the position of the labels. In our plot, some of the labels fall on top of each other. The package `ggrepel` includes a geometry that adds labels while ensuring that they don’t fall on top of each other. We simply change `geom_text` with `geom_text_repel`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(ggrepel)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggrepel\n```\n\n\n:::\n\n```{.r .cell-code}\np + geom_point(aes(col=Species, size = 3, alpha = 1/2)) +\n  scale_color_manual(values=cols) + \n  theme_economist() +\n  geom_text_repel(aes(Petal.Length, Petal.Width, label = id))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: ggrepel: 90 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n\n# Putting it all together\n\nNow that we are done testing, we can write one piece of code that produces our desired plot from scratch.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris$id <- 1:length(iris$Species)\ncols <- c(\"darkorange\", \"navyblue\", \"deeppink\")\nnames(cols) <- c(\"versicolor\", \"virginica\", \"setosa\")\n\niris |> ggplot(aes(x = Petal.Length, y = Petal.Width, col=Species)) + \n  geom_point(aes(size=3, alpha=1/2)) +\n   geom_smooth(method=\"lm\") +\n  scale_color_manual(values=cols) + \n  theme_economist() \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n\nI left off the point labels because itʻs too busy, but you can modify as you wish! It is often useful to label points when you are data cleaning or if you are interested in highlighting certain points. In that case, you could label only  specific points. \n\n# Saving\n\nYou can save your plots using the base R `pdf()` and `dev.off()` combination, opening the device, printing your plots, then closing the device. \n\nThere is also a `ggsave()` function specifically to save ggplot objects to different format. Check out the help page for it.  \n\n# Exercises\n\n1. In the final ggplot above, modify it to label only point 50, 100, and 150.  Hint: You can make another column of the iris dataframe that has labels only on those specific rows, and use that as your label argument. \n2. Try making a different kind of plot from the same data. Maybe a violin plot? Or any plot of your choice. \n3. Try plotting a different kind of data using ggplot (maybe a discrete variable?).  You can look at the built-in `mtcars` dataset or any new dataset.  \n \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}