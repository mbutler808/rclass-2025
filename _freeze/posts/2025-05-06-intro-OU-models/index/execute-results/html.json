{
  "hash": "5565e452d3736997914b6a9628a69fa5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to OU Models\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Comparative analyses with Ornstein-Uhlenbeck models\"\ndate: 2025-05-06\ncategories: [module 8, week 15, comparative analysis, phylogenetic trees, Ornstein Uhlenbeck, Brownian motion]\nbibliography: ../refs.bib\n---\n\n\n\n# Learning objectives\n\n::: callout-note\n# Learning Objectives\n__Goals:__\n-  Approaches for adaptive evolution (`ouch`, `slouch`, others)\n-  Model-based vs statistical approaches\n\n__Concepts:__\n-  Model comparison tools in R\n-  Process-based models\n\n__[Slides](OUCHintro-simplified.pdf)__\n:::\n\n# Introduction to OU Models\n\n## The OU Model for Comparative Analysis\n\nA Brownian motion process can be described using the following differential equation:  \n\n$$\n  dX(t) = \\sigma\\,dB(t).\n$${#eq-bm}\n\nIf we imagine the phenotype $X$ as changing through time $t$, this equation says that in a small increment of time, the change will be proportional to the parameter $\\sigma$. Here, $dB(t)$ is a sample from a Brownian (white noise) process. \n\nA small step towards reality is the OU Process:  \n\n$$\n  dX(t) = \\alpha\\,(\\theta - X(t))\\,dt + \\sigma\\,dB(t).\n$${#eq-basic_ou}\n\nEq. @eq-basic_ou expresses the amount of change in character $X$ over the course of a small increment of time: specifically, $dX(t)$ is the infinitesimal change in the character $X$ over the infinitesimal interval from time $t$ to time $t+dt$. The term $dB(t)$ is _white noise_; that is, the random variables $dB(t)$ are independent and identically-distributed normal random variables, each with mean zero and variance $dt$.  The parameter $\\alpha$ measures the strength of selection.  When $\\alpha = 0$, the deterministic part of the OU model is diminished and @eq-basic_ou approaches the familiar BM model of pure drift,\n\n## `ouch` package\n\nSee `ouch` lecture.\n\nGood starting points available in package `ouch`:  \n- `?bimac` help page for *Bimaculatus* character displacement dataset   \n- `example(bimac)`  example of bimac analysis\n- `?anolis.ssd` help page for *Anolis* sexual size dimorphism dataset\n\n\n`ouch` is a package designed to test adaptive hypotheses using variations of the OU process, including BM [@Butler:2004;@King:2022]. OUCH implements a model that fits _alpha_ and _sigma_ parameters to the entire  phylogeny, but allows the user to specify which branches belong to different selective regimes. The location of the optima are also fit. \n\n### The Data\nThe data in OUCH are most easily assembled as a data frame. Load the built in example from ouch and then print it to the screen (I only printed the head of the dataset here):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(ouch)\ndata(bimac)\nbimac\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ouch\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  node spcode species island size ancestor time OU.1   OU.3 OU.4  OU.LP\n1    1   <NA>    <NA>   <NA>   NA       NA    0   ns medium  anc medium\n2    2   <NA>    <NA>   <NA>   NA        1   12   ns medium  anc medium\n3    3   <NA>    <NA>   <NA>   NA        2   32   ns medium  anc  small\n4    4   <NA>    <NA>   <NA>   NA        3   34   ns medium  anc  small\n5    5   <NA>    <NA>   <NA>   NA        4   36   ns medium  anc  small\n6    6   <NA>    <NA>   <NA>   NA        3   36   ns medium  anc  small\n```\n\n\n:::\n:::\n\n\n\nNOTE: a very important detail about `ouch` is that it matches trees with data and regimes using the node labels stored in the rownames of the objects you pass to the `ouch` functions. So it is important to make sure that your dataframes and vectors are appropriately named. _The dataframe bimac already has the correct row names_, but we do so here just to illustrate. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(bimac) <- bimac$node\n```\n:::\n\n\n\n`ouch` was designed around a rectangular data model, so although the tree object is not a dataframe internally, it still helps us to build the data as a dataframe before making the `ouchtree` objects. The central organizing element is the \n`node`: it has a node number (usually an integer but it is actually a unique character string), an `ancestor` to which it is joined by a branch, a `time` since the root of the tree, and optional `label` such as a species name. \n\n### The hypotheses\n\n_The hypotheses which we use are assigned by painting particular regimes on branches_. It is convenient to represent each model or hypothesis as a column on the dataframe, with the regime assigned to the node (that is, it is assigned to the branch connecting the node to its ancestor).    \n\nMake an `ouchtree` object using the `ouchtree` constructor. `with` is a very nice function to create a small local environment so that you can use a dataframe's elements directly without using the `bimac$` prefix. \n\nIt is similar to an `attach` but it is temporary -- only lasting as long as the call itself. I like it much better than `attach` because I sometimes forget what I've attached and run into problems later. Also, with `attach`, you are actually working with a copy of the original dataframe object, so updating values is tricky. With `with`, it is more clear what's going on, and I don't tend to make those mistakes.\n\n\n\n::: {.cell fig='true'}\n\n```{.r .cell-code}\ntree <- with(bimac, ouchtree(node,ancestor,time/max(time),species))\nplot(tree)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n`ouch` fits the OU model Eq. @eq-basic_ou along each branch of the phylogeny. While $\\alpha$ and $\\sigma$ are held constant across the entire tree, the optima along each branch $\\theta$ are allowed to vary. Users can then paint various combinations of optima on the tree to reflect various biological scenarios. \n\nFor example, the dataset `bimac` was used to test the hypothesis of character displacement using an interspecific daaset of body sizes and sympatry/allopatry @Butler:2004. The analysis tested several different models, which are included with `bimac`. They are: OU.1 or global optimum, OU.3 or small, medium, and large regimes depending on the body size of the observed species (terminal branches only, internal branches painted medium, OU.4 or the same as OU.3 but with internal branches given their own unique regime called ancestral, and OU.LP based on a linear parsimony reconstruction of the colonization events (i.e., that as species came into sympatry, they diverged in body size). \n\n### Plotting `ouchtree`s\n\nYou can plot the regime paintings on the tree, and set options such as line widths for prettier plots. `ouch` has a very nice feature which allows plotting of the alternative models on one plot.\n\n\n\n::: {.cell fig='true'}\n\n```{.r .cell-code}\nplot(tree, regimes=bimac[c(\"OU.1\", \"OU.3\", \"OU.4\", \"OU.LP\")], lwd=6)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nRemember that you can pass a single vector or a data frame to the regimes parameter, but it must have the appropriate row names or names in the case of a vector.  The regimes are not part of the ouchtree object, because they represent our hypothesis of evolution along the tree, rather than the tree itself. It is part of the original dataframe from which we derived the tree, so remember to refer to `bimac` when passing the regimes to the `plot` function.  \n\n### Fitting models\n\nThere are two main model fitting functions in `ouch`, `brown`, which fits Brownian motion models, and `hansen`, which fits OU models to comparative data. The call to `brown` is particularly simple, as it takes only the data and the tree:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrown(log(bimac['size']),tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\ncall:\nbrown(data = log(bimac[\"size\"]), tree = tree)\n   nodes ancestors     times             labels     size\n1      1      <NA> 0.0000000               <NA>       NA\n2      2         1 0.3157895               <NA>       NA\n3      3         2 0.8421053               <NA>       NA\n4      4         3 0.8947368               <NA>       NA\n5      5         4 0.9473684               <NA>       NA\n6      6         3 0.9473684               <NA>       NA\n7      7         1 0.2105263               <NA>       NA\n8      8         7 0.3421053               <NA>       NA\n9      9         8 0.4736842               <NA>       NA\n10    10         9 0.6052632               <NA>       NA\n11    11        10 0.7368421               <NA>       NA\n12    12         9 0.7368421               <NA>       NA\n13    13         8 0.5789474               <NA>       NA\n14    14        13 0.6842105               <NA>       NA\n15    15        14 0.8947368               <NA>       NA\n16    16        15 0.9473684               <NA>       NA\n17    17         7 0.7368421               <NA>       NA\n18    18        17 0.7894737               <NA>       NA\n19    19        18 0.8947368               <NA>       NA\n20    20        19 0.9473684               <NA>       NA\n21    21        20 0.9736842               <NA>       NA\n22    22        19 0.9473684               <NA>       NA\n23    23         2 1.0000000       Anolis pogus 2.602690\n24    24         4 1.0000000   Anolis schwartzi 2.660260\n25    25         5 1.0000000   Anolis schwartzi 2.660260\n26    26         5 1.0000000   Anolis schwartzi 2.653242\n27    27         6 1.0000000     Anolis wattsii 2.674149\n28    28         6 1.0000000     Anolis wattsii 2.701361\n29    29        10 1.0000000 Anolis bimaculatus 3.161247\n30    30        11 1.0000000 Anolis bimaculatus 3.299534\n31    31        11 1.0000000 Anolis bimaculatus 3.328627\n32    32        12 1.0000000      Anolis leachi 3.353407\n33    33        12 1.0000000      Anolis leachi 3.360375\n34    34        13 1.0000000     Anolis nubilus 3.049273\n35    35        14 1.0000000     Anolis sabanus 2.906901\n36    36        15 1.0000000  Anolis gingivinus 2.980619\n37    37        16 1.0000000  Anolis gingivinus 2.933857\n38    38        16 1.0000000  Anolis gingivinus 2.975530\n39    39        17 1.0000000    Anolis oculatus 3.104587\n40    40        18 1.0000000     Anolis ferreus 3.346389\n41    41        20 1.0000000     Anolis lividus 2.928524\n42    42        21 1.0000000  Anolis marmoratus 2.939162\n43    43        21 1.0000000  Anolis marmoratus 2.990720\n44    44        22 1.0000000 Anolis terraealtae 3.058707\n45    45        22 1.0000000 Anolis terraealtae 3.068053\n\nsigma squared:\n           [,1]\n[1,] 0.04311003\n\ntheta:\nNULL\n   loglik  deviance       aic     aic.c       sic       dof \n 17.33129 -34.66257 -30.66257 -30.06257 -28.39158   2.00000 \n```\n\n\n:::\n:::\n\n\n\nWhat is returned is an object of class `browntree`. It contains all input including the function call,  the tree and data), as well as the parameter estimate for $\\sigma$ and the model fit statistics including: the log-likelihood, the deviance ($-2*log(L)$), the information criteria $AIC$, $AIC_c$ (corrected for small sample size), and $SIC$, and the model degrees of freedom. \n\nIt is a good practice to save this, as it encapsulates the analysis. From this, we can rerun the model fit. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh1 <- brown(log(bimac['size']),tree)\n```\n:::\n\n\n\n`hansen` models are slightly more complex. In addition to $\\sigma$, we are now fitting $\\alpha$, the strength of selection, and all of the optima $\\theta$ specified by our model. This maximum-likelihood search now requires an initial guess. If you have no idea, a good starting guess is 1. If you want to be sure, you can intiate searches with different starting guesses. You can also specify alternative optimization algorithms and increase or decrease the relative tolerance, which is the stringency by which convergence is assessed. Typically, the default is roughly `reltol=1e-8`, and the limit of machine precision is in the neighborhood of `reltol=1e-15`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh2 <- hansen(log(bimac['size']),\n             tree,\n             bimac['OU.1'],\n             sqrt.alpha=1,\n             sigma=1)\nh3 <- hansen(log(bimac['size']),\n             tree,bimac['OU.3'], \n             sqrt.alpha=1,\n             sigma=1)\nh4 <- hansen(log(bimac['size']),\n             tree,\n             bimac['OU.4'], \n             sqrt.alpha=1,\n             sigma=1)\nh5 <- hansen(log(bimac['size']),\n             tree,\n             bimac['OU.LP'], \n             sqrt.alpha=1,\n             sigma=1,\n             reltol=1e-5)\n```\n:::\n\n\n\n### `hansentree` and `ouchtree` methods\n\nWe can see the model results by typing `h5`, which will execute the `print` method for this class. You could also use the `attributes` function, but this will dump too much information. `ouchtree` objects and the classes derived from them contain information that is used in internal calculations of the algorithms, not of general interest to users. \n\nAdditional accessor functions include: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(h5)    # the coefficients of the fitted model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$sqrt.alpha\n[1] 1.61658\n\n$sigma\n[1] 0.2249274\n\n$theta\n$theta$size\n   large   medium    small \n3.355087 3.040729 2.565249 \n\n\n$alpha.matrix\n        [,1]\n[1,] 2.61333\n\n$sigma.sq.matrix\n           [,1]\n[1,] 0.05059232\n```\n\n\n:::\n\n```{.r .cell-code}\nlogLik(h5)   # the log-likelihood value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24.81823\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(h5) # (not printed) everything except the tree+data\n```\n:::\n\n\n\nWe can now generate a table of our model fits: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n    # just the model fit statistics on a single line\nunlist(summary(h5)[c('aic', 'aic.c', 'sic', 'dof')])  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      aic     aic.c       sic       dof \n-39.63645 -36.10704 -33.95898   5.00000 \n```\n\n\n:::\n\n```{.r .cell-code}\nh <- list(h1, h2, h3, h4, h5)   # store fitted models in a list\nnames(h) <- c('BM', 'OU.1', 'OU.3', 'OU.4', 'OU.LP')\nsapply( h, function(x)\n             unlist(\n                summary(x)[c('aic', 'aic.c', 'sic', 'dof')]\n             ) \n      )                         # table with all models\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             BM      OU.1      OU.3      OU.4     OU.LP\naic   -30.66257 -25.39364 -29.15573 -35.22319 -39.63645\naic.c -30.06257 -24.13048 -25.62631 -29.97319 -36.10704\nsic   -28.39158 -21.98715 -23.47826 -28.41022 -33.95898\ndof     2.00000   3.00000   5.00000   6.00000   5.00000\n```\n\n\n:::\n:::\n\n\n\nBy storing the model fits in a list, we can use apply methods to get the statistics from all the models at once. `sapply` returns a matrix if possible. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh.ic <- sapply( h, function(x) \n                     unlist(\n                      summary(x)[c('aic', 'aic.c', 'sic', 'dof')]\n                     ) \n               )  \nprint( h.ic, digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         BM  OU.1  OU.3  OU.4 OU.LP\naic   -30.7 -25.4 -29.2 -35.2 -39.6\naic.c -30.1 -24.1 -25.6 -30.0 -36.1\nsic   -28.4 -22.0 -23.5 -28.4 -34.0\ndof     2.0   3.0   5.0   6.0   5.0\n```\n\n\n:::\n:::\n\n\n\n### Simulation and bootstrap methods:\n\n`simulate` generates random deviates or sets of simulated tip data based on the fitted model. The input is a fitted model `hansentree` or `browntree`, and the output is a list of dataframes, each comparable to the original data. These can then be used to refit the model. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nh5.sim <- simulate(object = h5, nsim=10)   # saves 10 sets of simulated data\n                                  #  based on OU.LP\n```\n:::\n\n\n\n`update` refits the model, with one or more parameters changed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary( update( object = h5, \n                 data = h5.sim[[1]] \n                )  # fit the first dataset\n        )   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$call\nhansen(data = data, tree = object, regimes = regimes, sqrt.alpha = sqrt.alpha, \n    sigma = sigma)\n\n$conv.code\n[1] 0\n\n$optimizer.message\nNULL\n\n$alpha\n         [,1]\n[1,] 3.406824\n\n$sigma.squared\n           [,1]\n[1,] 0.04658889\n\n$optima\n$optima$size\n   large   medium    small \n3.311852 3.017353 2.561983 \n\n\n$loglik\n[1] 27.77894\n\n$deviance\n[1] -55.55788\n\n$aic\n[1] -45.55788\n\n$aic.c\n[1] -42.02847\n\n$sic\n[1] -39.88041\n\n$dof\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nh5.sim.fit <- lapply( h5.sim, \n                      function(x) update(h5, x)\n                    ) # fit all 10 simulations\n```\n:::\n\n\n\n`bootstrap` is a convenience function for generating parametric bootstraps of the parameter estimates. It takes the fitted model, performs the simulations, refits, and outputs a dataframe of parameter estimates.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrap( object = h5, nboot=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       alpha sigma.squared optima.size.large optima.size.medium\n1   2.931962    0.06300679          3.406845           3.033368\n2   1.166652    0.02087730          3.442742           3.045020\n3   6.842407    0.13962883          3.327190           2.954449\n4   3.548455    0.05227364          3.312705           3.055402\n5   4.334962    0.04980428          3.274724           3.122849\n6   6.220885    0.07881881          3.282142           3.005847\n7   6.537493    0.06491762          3.235161           3.104050\n8   4.631713    0.06636800          3.349804           2.991356\n9  14.052840    0.10776110          3.330246           3.031296\n10  9.390043    0.11391753          3.252886           3.052051\n   optima.size.small   loglik       aic     aic.c       sic dof\n1           2.472794 23.14495 -36.28990 -32.76049 -30.61243   5\n2           2.211821 30.17167 -50.34334 -46.81392 -44.66587   5\n3           2.724776 21.28855 -32.57711 -29.04770 -26.89964   5\n4           2.525664 26.78157 -43.56315 -40.03373 -37.88567   5\n5           2.556321 29.00157 -48.00314 -44.47373 -42.32567   5\n6           2.711134 26.96231 -43.92463 -40.39521 -38.24716   5\n7           2.617113 29.66251 -49.32502 -45.79561 -43.64755   5\n8           2.546844 26.27175 -42.54351 -39.01410 -36.86604   5\n9           2.656652 31.62991 -53.25981 -49.73040 -47.58234   5\n10          2.710166 26.75359 -43.50717 -39.97776 -37.82970   5\n```\n\n\n:::\n:::\n\n\n\n### `paint`ing regimes on trees\n\nA new function in `ouch` is `paint`. Previously, it was up to users to set up regimes manually by editing spreadsheets. `paint` helps with this task by specifying the regimes on particular species, subtrees, or particular branches.\n\nThere are two parameters to `paint`, `subtrees`, which paints the entire subtree which descends from the node, and `branch`, which paints the branch connecting the node to it's ancestor. For either, you specify the node label (remember it's a character and needs to be quoted), and set it equal to the name of the regime you want to specify. \n\nLet's try it on the `bimac` tree and try to recreate the OU.LP regime:\n\n\n::: {.cell fig='true'}\n\n```{.r .cell-code}\nplot(tree, node.names=T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nPaint the subtrees first, take a look:\n\n\n::: {.cell fig='true'}\n\n```{.r .cell-code}\nou.lp <- paint( tree, \n                subtree=c(\"1\"=\"medium\",\"9\"=\"large\",\"2\"=\"small\") \n               )\nplot(tree, regimes=ou.lp, node.names=T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nBut there was an independent switch from medium to large at species gm, or node 38, and the node connecting 9 to its ancestor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nou.lp <- paint( tree, \n                subtree=c(\"1\"='medium',\"9\"='large',\"2\"='small'),\n                branch=c(\"38\"='large',\"2\"='medium')\n              )  \n```\n:::\n\n\n\nCompare it to the original OU.LP from above. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(tree, regimes=ou.lp, node.names=T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nWe can create alternative paintings of the regimes to test against the data. Suppose we wanted to add a clade specific hypothesis that diverged in a similar time period (this is a completely made-up hypothesis, just for example):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nou.clades <- paint( tree, \n                    subtree=c(\"1\"=\"A\",\"7\"=\"B\", \"8\"=\"C\"), \n                    branch=c(\"8\"=\"C\", \"7\"=\"C\", \"1\"=\"A\")\n                   )\nplot(tree, regimes=ou.clades, node.names=T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n \nRun the model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh6 <- hansen( \n              log(bimac['size']),\n              tree, \n              regimes=ou.clades, \n              sqrt.alpha=1,\n              sigma=1\n            )\n```\n:::\n\n\n\nRebuild our table and compare models:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- append(h, h6)         # append (add on) new model results to our list h\nnames(h)[length(h)] <- ou.clades    # add the name of the new model\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in names(h)[length(h)] <- ou.clades: number of items to replace is not\na multiple of replacement length\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(h)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"BM\"    \"OU.1\"  \"OU.3\"  \"OU.4\"  \"OU.LP\" \"1\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nh.ic <- sapply( h, function(x) \n                     unlist(\n                        summary(x)[c('aic', 'aic.c', 'sic', 'dof')]\n                     ) \n               )  \nprint( h.ic, digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         BM  OU.1  OU.3  OU.4 OU.LP     1\naic   -30.7 -25.4 -29.2 -35.2 -39.6 -30.7\naic.c -30.1 -24.1 -25.6 -30.0 -36.1 -27.1\nsic   -28.4 -22.0 -23.5 -28.4 -34.0 -25.0\ndof     2.0   3.0   5.0   6.0   5.0   5.0\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}