{
  "hash": "c380b846a6604dcc2d6e172f967c2e2f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Plotting Systems\"  \nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Showing you base plotting, lattice, and ggplot2\"  \ndate: 2025-02-20\ncategories: [module 3, week 5, plotting, ggplot2, lattice, data visualization]  \n---\n\n\n\n> The data may not contain the answer. And, if you torture the data long enough, it will tell you anything. ---*John W. Tukey*\n\n<!-- R emoji aliases:  https://gist.github.com/rxaviers/7360908 -->\n#✏️\n\n\n# Addtional Resources\n\n### Excellent references\n\n::: callout-note\n## For more details see\n\n1.  <https://r4ds.had.co.nz/data-visualisation>\n2.  Paul Murrell (2011). *R Graphics*, CRC Press.\n3.  Hadley Wickham (2009). *ggplot2*, Springer.\n4.  Deepayan Sarkar (2008). *Lattice: Multivariate Data Visualization with R*, Springer.\n:::\n\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-13-plotting-systems/> \n-   <https://rdpeng.github.io/Biostat776/lecture-plotting-systems>\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to identify and describe the three plotting systems in R\n-   Be able to implement simple plots in each\n:::\n\n\n# Overview \n\nThere are **three different plotting systems in R** and they each have different characteristics and modes of operation.\n\n::: callout-tip\n### Important\n\nThe three systems are\n\n1.  The base plotting system\n2.  The lattice system\n3.  The ggplot2 system\n\n**This course will focus primarily on the base and ggplot2 plotting systems**. Lattice is presented for context.\n:::\n\nIf you don't have these already, please install: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"lattice\", \"ggplot2\"))\n```\n:::\n\n\n\n## The Base Plotting System\n\nThe **base plotting system** is the original plotting system for R. The basic model is sometimes **referred to as the \"artist's palette\" model**, because you start with a blank canvas and add to it, element by element. \n\nWe begin with an R plotting function that *creates a new plot window* **typically the `plot()` function**, which creates a plot object. We can add *annotations* to the plot object with functions such as (`text`, `lines`, `points`, `axis`). \n\nIf you get an error \n```{.bash}\nError in plot.xy(xy.coords(x, y), type = type, ...) : \n  plot.new has not been called yet\n```\n\nIt is probably because you tried to add an annotation before you created a plot first. \n\nThe base plotting system is **often the most convenient plotting system** to because it mirrors the cartesian coordinate (X,Y) syntax that we sometimes think of when building plots and analyzing data.\n\nIt is also the most customizablbe because there are many options that users can specify. See the help page for `?plot.default` and `?par` for graphical parameters that once can set. It does take some learning, but it is possible to make multi-figure plots while precisely controlling their placement, margins, and any annotations including points, lines, text etc. \n\nThe plot system is also very useful at the very beginning of a data analysis When we donʻt precisely know what we want to plot. We can start by \"throwing some data on the page\" and then slowly modifying or adding more information to it as our thought process evolves.\n\n::: callout-tip\n### Example\n\nWe might look at a simple scatterplot and then decide to add a linear regression line or a smoother to it to highlight the trends.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(airquality)\nwith(airquality, {\n        plot(Temp, Ozone)\n        lines(loess.smooth(Temp, Ozone))\n})\n```\n\n::: {.cell-output-display}\n![Scatterplot with loess curve](index_files/figure-html/unnamed-chunk-2-1.png){width=480}\n:::\n:::\n\n\n:::\n\nIn the code above:\n\n-   The `plot()` function creates the initial plot and draws the points on the canvas.\n-   The `lines` function is used to annotate or add to the plot (in this case it adds a loess smoother to the scatterplot). \n-   R has many other types of [smoothing functions](https://blog.revolutionanalytics.com/2015/09/interpolation-and-smoothing-functions-in-base-r.html) as well. \n\n\nNext, we use the `plot()` function to draw the points on the scatterplot and then use the `main` argument to add a main title to the plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(airquality)\nwith(airquality, {\n        plot(Temp, Ozone, main = \"my plot\")\n        lines(loess.smooth(Temp, Ozone))\n})\n```\n\n::: {.cell-output-display}\n![Scatterplot with loess curve](index_files/figure-html/unnamed-chunk-3-1.png){width=480}\n:::\n:::\n\n\n\nOne downside with constructing base plots is that **annotations can only be added**. If your annotations are crashing, or you run out of room, etc., you will have to rerun the code starting from plot(). \n\nAnd while the base plotting system is nice in that it gives you the flexibility to specify these kinds of details to painstaking accuracy, **sometimes it would be nice if the system could just figure it out for you**. Thatʻs where `lattice` and `ggplot2` have contributed. \n\nAnother downside of the customizability of the base plotting system is that it is **difficult to describe or translate a plot to others because there is no clear graphical language or grammar**. In other words, you cannot paint the format of one onto another plot, unless you design the code (maybe by using the same variable names, etc.) to do it yourself. \n\nThe only real way to describe what you have done in a base plot is to just list the series of commands/functions that you have executed, which is not a particularly compact way of communicating things. The `ggplot2` package has developed a grammar of graphics that make transferring formats easy.\n\n::: callout-tip\n### Example\n\nAnother typical base plot for a linear regression is constructed with the following code.\nHere we are using *formula representation*. Instead of `plot(x,y)` we use `plot(y~x)` which is read \"plot y as a function of x\". These styles are equivalent, but formula is in the style of regression models. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(cars)\n\n## Create the plot / draw canvas\nwith(cars, plot(dist ~ speed))\n```\n\n::: {.cell-output-display}\n![Base plot with title](index_files/figure-html/unnamed-chunk-4-1.png){width=480}\n:::\n\n```{.r .cell-code}\n## Fit a linear model and save it\nlm.fit <- with(cars, lm( dist ~ speed))\n```\n:::\n\n\n\nWe can add annotations as before. This time, to add the regression line to the plot, we use the `abline()` function which adds straight lines, specified by slope and intercept. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(cars, plot(dist ~ speed))\n\n## Add annotations\ntitle(\"Linear model of speed vs. stopping distance\")\nabline(lm.fit, col=\"red\")\ntext(7, 120, paste(\"slope =\", round(coef(lm.fit)[2], digits=2)))\ntext(7, 110, paste(\"intercept =\", round(coef(lm.fit)[1], digits=2)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nUsing `text()` we added the slope and intercept from the linear model fit. That information is returned by the `coef()` function. We used `round()` to make it prettier (8 decimal places is not necessary!)\n:::\n\n## The Lattice System\n\nThe **lattice plotting system** is ideal for visualization of multivariate data, and is implemented in the `lattice` R package which comes with every installation of R (although it is not loaded by default).\n\nTo **use the lattice plotting functions**, you must first load the `lattice` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lattice)\n```\n:::\n\n\n\nWith the lattice system, **plots are created with a single function call**, such as `xyplot()` or `bwplot()`, and the plot is delivered in a predefined format. \n\nThere is **no real distinction between functions that create or initiate plots** and **functions that annotate plots** because it all happens at once.\n\nLattice plots tend to be **most useful for conditioning types of plots**, i.e. looking at how `y` changes with `x` across levels of `z`.\n\n-   e.g. these types of plots are useful for looking at multi-dimensional data and often allow you to squeeze a lot of information into a single window or page.\n\nAnother aspect of lattice that makes it different from base plotting is that **things like margins and spacing are set automatically**.  The downside is that it is not very customizable. \n\n::: callout-tip\n### Example\n\nHere is a lattice plot that looks at the relationship between life expectancy and income and how that relationship varies by region in the United States.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate <- data.frame(state.x77, region = state.region)\nhead(state)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Population Income Illiteracy Life.Exp Murder HS.Grad Frost   Area\nAlabama          3615   3624        2.1    69.05   15.1    41.3    20  50708\nAlaska            365   6315        1.5    69.31   11.3    66.7   152 566432\nArizona          2212   4530        1.8    70.55    7.8    58.1    15 113417\nArkansas         2110   3378        1.9    70.66   10.1    39.9    65  51945\nCalifornia      21198   5114        1.1    71.71   10.3    62.6    20 156361\nColorado         2541   4884        0.7    72.06    6.8    63.9   166 103766\n           region\nAlabama     South\nAlaska       West\nArizona      West\nArkansas    South\nCalifornia   West\nColorado     West\n```\n\n\n:::\n\n```{.r .cell-code}\nxyplot(Life.Exp ~ Income | region, data = state, layout = c(4, 1))\n```\n\n::: {.cell-output-display}\n![Lattice plot](index_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n:::\n\nYou can see that the entire plot was generated by the call to `xyplot()` and all of the data for the plot were specified to come from the `state` data frame.\n\nThe **layout** specifies four panels ---one for each region--- **within each panel is a scatterplot** of life expectancy and income. Note that in this case, layout is columns, rows. Try changing the numbers or leaving out the layout argument and see what happens. \n\nThe notion of *panels* comes up a lot with lattice plots because you typically have many panels in a lattice plot (each panel typically represents a *factor level*, like \"region\").\n\n::: callout-tip\n### Note\n\nDownsides with the lattice system\n\n-   It can sometimes be very **awkward to specify an entire plot** in a single function call (you end up with functions with many many arguments).\n-   **Annotation in panels in plots is not especially intuitive** and can be difficult to explain. In particular, the use of custom panel functions and subscripts can be difficult to wield and requires a lot of trial and error.\n:::\n\n## The ggplot2 System\n\nThe **ggplot2 plotting system** attempts to split the difference between base and lattice in a number of ways.\n\n::: callout-tip\n### Note\n\nTaking cues from lattice, the ggplot2 system automatically deals with spacings, text, titles but also allows you to annotate by \"adding\" to a plot, with annotations added in layers.\n:::\n\nThe ggplot2 system is implemented in the `ggplot2` package (part of the `tidyverse` package), which is available from CRAN (it does not come with R).\n\nYou can install it from CRAN via\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\n\nand then load it into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n\nSuperficially, the `ggplot2` functions are similar to `lattice`, but the system is generally easier and more intuitive to use once you learn the syntax.\n\nThe defaults used in `ggplot2` make many choices for you, but you can still customize plots.\n\n::: callout-tip\n### Example\n\nA typical plot with the `ggplot2` package looks like the code below. \n\nNote the use of the pipe operator `%>%` from the `magrittr` package in the tidyverse, which sends the dataframe `mpg` as input into the function ggplot. People love the pipe operator because you can just pass output along from one function to the next (as long as the function is written for piping). All of the tidyverse allows piping, and some base R functions do as well. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndata(mpg)\nmpg %>%\n  ggplot(aes(displ, hwy)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![ggplot2 plot](index_files/figure-html/unnamed-chunk-10-1.png){width=576}\n:::\n:::\n\n\n:::\n\nIn `ggplot`, elements of the plot are specified as **aesthetics**, and layers can be added onto the plot with `+ anotherfunction()`. Try running the first part, and then running the whole thing  together. Then try adding `+ geom_smooth()`\n\nThere are additional functions in `ggplot2` that allow you to make arbitrarily sophisticated plots.\n\nWe will discuss more about this in the next lecture.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}