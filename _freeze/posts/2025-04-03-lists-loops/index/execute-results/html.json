{
  "hash": "80a072cdbd185c19747e262bac1eb60f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lists and For-Loops\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Donʻt get frustrated, learn a few simple rules about lists. Then you can massively scale.\"\ndate: 2025-04-03\ncategories: [module 5, week 10, lists, for loops, programming]\n---\n\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Understand the special features of lists\n-   Be able to access list elements and write to lists\n-   Be able to construct a for loop for repeated computation\n-   Have gained another skill in modular programming\n:::\n\n# Overview\n\nWe've been introduced to _lists_, but here we will gain a better understanding of some of their special features and how to use them to write more powerful code. Lists and counted loops (for loops) work really well together when you want to scale up to __repeated computation__. \n\nLists are commonly returned from functions because functions can only return one object. Any collection of objects can be put together into a single list. \nFunctions (and any other R element) can be used together with for loops to improve modularity and readabilty. \n\nR also has special functions that operate along lists, called `apply()` functions, which we will learn about in the next lesson. \n\n\n\n# Lists\n\nLists in R are vectors like any other vector, but more flexible in that elements of a list can have different data types. This has at least three consequences. \n\n-  First any operation that you can perform on a vector can also be done on a list. \n-  Second, any types of objects can be organized together into a list, which are very convenient for things like model fits, where you may want to store the model formula, the data, the coefficients, any likelihood values, and any other relevant information together into one data object. \n-  Third, you can use lists as containers for containers, which can be nested indefinitely. \n\nThe elements of lists can be __named__, either upon creation, or using the `names()` function. Naming list elements is always a good idea because it gives you another way of accessing their elements:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant <- list(fullname=\"Mickey Mouse\", address=\"123 Main St.\",  state=\"CA\")\napplicant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n\n$address\n[1] \"123 Main St.\"\n\n$state\n[1] \"CA\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(applicant) <- c(\"fullname\", \"address\", \"state\")\napplicant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n\n$address\n[1] \"123 Main St.\"\n\n$state\n[1] \"CA\"\n```\n\n\n:::\n:::\n\n\n\nWe can also use all of the standard functions that work on vectors, such as the combine function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant <- c(applicant, list(scores=matrix(1:10, nrow=2)))\napplicant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n\n$address\n[1] \"123 Main St.\"\n\n$state\n[1] \"CA\"\n\n$scores\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n:::\n\n\n\nIf we had multiple applicants, we could put them all together in a list of lists. \n\n\n## Accessing list elements\n\n::: {.callout-tip}\n# A lot of people get tripped up working with lists, but the same rules apply to lists as other objects. \nThere are just a couple of additional things:\n\n-    The double bracket, and  \n-   The heirarchy of objects.  \n\nOnce you understand that, itʻs simply applying the rules. \n:::\n\n__List elements__ can be accessed with the usual operators for vectors:\n\n- __$__ If the list is named\n- __[ ]__ By number or name of the list element with single brackets. Returns a list. Can use a vector of indices or names.\n- __[[ ]]__ By number or name with double brackets. Returns the element inside the list slot. Must be a single index or name. \n\n__By name__\nThis is why itʻs a good idea to name list elements.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant$fullname\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mickey Mouse\"\n```\n\n\n:::\n\n```{.r .cell-code}\napplicant[1]   ## returns a list of length one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n```\n\n\n:::\n\n```{.r .cell-code}\napplicant[[1]]  ## returns the object within applicant[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mickey Mouse\"\n```\n\n\n:::\n:::\n\n\n\n__Single brackets return lists__. \nWe can select multiple elements within single brackets:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n\n$address\n[1] \"123 Main St.\"\n```\n\n\n:::\n\n```{.r .cell-code}\napplicant[c(\"fullname\", \"address\")]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n\n$address\n[1] \"123 Main St.\"\n```\n\n\n:::\n:::\n\n\n\n__Double brackets return the element within the list slot__. \nBut we can only select one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mickey Mouse\"\n```\n\n\n:::\n\n```{.r .cell-code}\napplicant[[\"fullname\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mickey Mouse\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant[[1:2]]  ## cannot subset [[]] with more than one index\n```\n:::\n\nError in applicant[[1:2]] : subscript out of bounds\nError in applicant[[1:2]] : subscript out of bounds\n\n\n\n__Exclusion index (drops the `state` slot)__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant[-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fullname\n[1] \"Mickey Mouse\"\n\n$address\n[1] \"123 Main St.\"\n\n$scores\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n:::\n\n\n\n__Accessing elements inside an object within a list__:\nHere we want to access elements of a matrix which is in a list. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napplicant[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$scores\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n\n```{.r .cell-code}\napplicant[[4]][2,1]  # Take the scores matrix, and grab row 2, column 1.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\napplicant[[4]][,3]  # Take the scores matrix, and grab all of column 3.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6\n```\n\n\n:::\n:::\n\n\n\n# For loops \n\nBecause of the flexibility of lists, they are useful containers for the output of loops or other repeated operations on data. What is a loop you may ask? It is a set of code that you want to execute repeatedly.  For example, you may have a large number of datasets that you want to perform the same set of operations on. \n\nThe easiest type of loop to understand is the `for` loop. It is a __counted loop__, or repeated a fixed number of times. You may be familiar with for loops (or for-next loops) from other computing languages. In R the for loop operates over a vector, once for each element of the vector. The syntax is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (var in seq) expr\n```\n:::\n\n\n\nWhere `var` is a variable which takes on values of the vector `seq` and evaluates a block of code `expr`. The loop is evaluated once for each value of `seq`.  If we need `expr` to span more than one line, we can do this by enclosing the loop with `{}` (even if itʻs only one line itʻs often nice for readability).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) { \n   print(paste(\"This is a for loop\", i))\n}   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This is a for loop 1\"\n[1] \"This is a for loop 2\"\n[1] \"This is a for loop 3\"\n```\n\n\n:::\n:::\n\n\n\nIt is traditional to use `i`, `j`, or `k` as the variable to remember that itʻs a counting index, but it is often convenient to use names that are meaningful to understand the code. For example, in the context of our earlier example, it might be helpful to iterate over each applicant in our applicant list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (applicant in applicant_list) expr\n```\n:::\n\n\n\n### Saving loop output to lists \n\nOften we want to save the result or output of the code to a list. But we donʻt want to create a list with each iteration of the loop, we just want to fill the list element or add on to the list. So in order to do this, we need to create the list **outside** of the loop and then modify it **inside** the loop. \n\nOne strategy is to fill the list element by element using the counter `i` (note that we donʻt have to tell R how long the list is when we create it. We can just make an empty list, R will just keep adding to `mylist`): \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- vector(\"list\")   ## creates a null (empty) list\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n\n```{.r .cell-code}\nfor (i in 1:4) {\n   mylist[i] <- list(data.frame(x=rnorm(3), y=rnorm(3)))  ## why does this have to be a list object?\n}\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n           x           y\n1 -2.0664829 -0.06630644\n2 -0.6457298  0.09193948\n3 -1.3209307 -0.35804207\n\n[[2]]\n          x          y\n1 1.0083777 -2.2168840\n2 0.1594035 -0.6398037\n3 0.3334048 -1.2897286\n\n[[3]]\n           x         y\n1  0.1600132 0.5446338\n2  0.5613610 1.3002046\n3 -0.1643584 2.1673106\n\n[[4]]\n           x          y\n1  2.3563131 -0.8401923\n2 -0.2548754  0.3033311\n3  0.5542937  2.0203079\n```\n\n\n:::\n:::\n\n\n\nThis code does the same thing, but uses the `c()` function to add on to `mylist` (what happens when you add on to a null list?):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- vector(\"list\")   ## creates a null (empty) list\nfor (i in 1:4) {\n   mylist <- c(mylist, list(data.frame(x=rnorm(3), y=rnorm(3))))\n}\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n           x          y\n1  0.7611693 -0.1729694\n2 -0.8270695 -0.2587277\n3 -0.4568445 -2.2191690\n\n[[2]]\n           x          y\n1 -0.8483475  0.6901542\n2  1.2085477 -1.3227949\n3  0.6653367 -0.8511435\n\n[[3]]\n            x          y\n1 -0.08962612  0.3813641\n2  0.29522739  0.5927765\n3  0.60853692 -0.1989251\n\n[[4]]\n          x          y\n1 1.4527501 -1.4109337\n2 1.0750919  0.7988422\n3 0.4043773 -0.7177023\n```\n\n\n:::\n:::\n\n\n\n### Reshaping lists\n\nYou often want to reshape list output in scientific programming. For example, you may fit models many times on many permutations of your data, for example, and you want to flatten your list and make a dataframe.  When you know that your output is regular, it is often convenient to use the `unlist()` function.  Unlist will also work on dataframes, because you know, dataframes are lists of vectors all of the same length.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.out <- lm( mylist[[1]]$x  ~ mylist[[1]]$y )  ## calculate a linear regression on dataframe 1 x as a function of y\naov.out <- anova(lm.out)   ## run anova, save to aov.out\naov.out\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: mylist[[1]]$x\n              Df  Sum Sq Mean Sq F value Pr(>F)\nmylist[[1]]$y  1 0.15014 0.15014   0.122 0.7861\nResiduals      1 1.23090 1.23090               \n```\n\n\n:::\n\n```{.r .cell-code}\nunlist(aov.out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Df1       Df2   Sum Sq1   Sum Sq2  Mean Sq1 \n1.0000000 1.0000000 0.1501384 1.2309038 0.1501384 \n Mean Sq2  F value1  F value2   Pr(>F)1   Pr(>F)2 \n1.2309038 0.1219741        NA 0.7860928        NA \n```\n\n\n:::\n:::\n\n\n\n\n### Exercises\n\n\n1.  Take mylist above and name its elements (the dataframes).  \n2.  Write another `for` loop to return the maximum value of x and y in each dataframe. How can you make the code flexible to make it work if mylist has a different length?\n3.  Write a `for` loop to loop over `mylist`. Within this loop, for each dataset compute an anova on `x ~ y`, `unlist` the anova output, and add as a row to a final dataframe. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}