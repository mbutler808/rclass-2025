{
  "hash": "83c02fbbb45957714a15a00e4767b14f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Phylogenetic Inference with IQTREE2\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Maximum Likelihood phylogenetic tree inference and gene-tree species-tree concordance\"\ndate: 2025-04-29\ncategories: [module 7, week 13, iqtree2, phylogenetic inference, command line, gene concordance, site concordance, gene tree, species tree]\nbibliography: ../refs.bib\n---\n\n\n\n### Acknowledgements\n\nReferences for this Material:\n\n- The Gene Tree species tree tutorial by Bui Minh <http://www.iqtree.org/workshop/molevol2022>.  Please see for more information. \n\n-  And Rob Lanfearʻs excellent blog post about concordance factors <http://www.robertlanfear.com/blog/files/concordance_factors.html> with R code to help with analysis. \n\n-  See Methods Paper: \nBui Quang Minh,  Matthew W Hahn,  Robert Lanfear\nNew Methods to Calculate Concordance Factors for Phylogenomic Datasets \nMolecular Biology and Evolution, Volume 37, Issue 9, September 2020, Pages 2727–2733,\n<https://doi.org/10.1093/molbev/msaa106>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Understand where user-installed software goes on your computer \n-   Be able to install software and update the search paths to run from the command line\n-   Run iqtree2 from the command line on your own computer\n\n:::\n\n:::{.callout-note}\n# Setup iqtree software\n\nInstructions for installing IQTREE2 and setup for this lession were provided in the [previous lesson](../2023-04-13-iqtree-setup/index.qmd). \n\n#### Setup your Tutorial Folder\n\nMake a `TurtleTutorial` folder, add the following files/folders:  \n\n-  Make an `input` folder and put these files into it:  \n    +  [turtle.fa](http://www.iqtree.org/workshop/data/turtle.fa) : A sequence alignment (in FASTA format) which is a subset of the original dataset used to assess the phylogenetic position of Turtles relative to Crocodiles and Birds [Chiari et al., 2012](https://doi.org/10.1186/1741-7007-10-65).  \n    +  [turtle.nex](http://www.iqtree.org/workshop/data/turtle.nex) : The partition file (in NEXUS format) defining 29 genes, which are a subset of the original dataset of 248 genes.   \n-  The R script [`concordance.R`](../../code/concordance.R) \n-  iqtree shell script: [`iqtreerun.sh`](../../code/iqtreerun.sh)\n-  If you donʻt want to setup IQTREE2 and infer the phylogenies yourself, you can clone the repo (or to get the files, clone the repo, delete the out directories, and run the scripts to get the phylogenies yourself) <https://github.com/mbutler808/TurtleTutorial>\n\n#### R packages you will need\n- `viridis`\n- `GGally`\n- `entropy`\n- `ggplot2`\n- `dplyr`\n- `ggrepel`\n:::\n\n\n# Overview\n\nWhen inferring phylogenies from sequence data, it is important to provide support values, usually at the nodes, to indicate how much evidence there is for each split along the phylogeny. The most common and familar are nodal support values - __bootstrap support__ in percent for __maximum likelihood trees__, and __posterior probability__ for trees inferred by __Bayesian inference__. \n\nIQTREE2 is software for the inference of phylogenies by __Maximum Likelihood__ [@Minh:2020]. \nSeveral additional modules are bundled with IQTREE2. __ModelFinder__ searches for the best substition models prior to phylogenetic inference [@Kalyaanamoorthy:2017]. ModelFinder can also combine partitions to reduce overparameterization, similar to __PartitionFinder__ [@Lanfear:2016].\n\nThere is an increasing recognition that nodal support is not enough. Most phylogenetic analyses are now multi-locus, with data from several to hundred of genes. More studies are discovering that not all of the loci may agree -- sometimes certain loci will support one topology whereas others may support an alternative topology. This is called gene-tree species-tree discordance. It can arise by evolutionary mechanisms such as incomplete lineage sorting when you have rapid radiation (short branch lengths in parts of the tree), where ancestral alleles do not have sufficient time to sort themselves out amongst the descendant lineages to reflect the history of cladogenesis, or it can arise by noisy data. Either way, if you have gene-tree species-tree discordance, it will erode support at nodes, or in the worst case, appear to strongly support a spurious evolutionary scenario. We can test for concordance between gene trees and species trees [@Minh:2020a]\n\nIn this module we will learn how to use [IQTREE2](www.iqtree.org) to infer phylogenetic trees (both species trees and gene trees), and compute several concordance factors. Gene concordance and discordance factors, and site concordance and discordance factors (site = position along the DNA sequence).  We will use R to read in and explore the output from IQTREE. \n\n\n# IQTREE and ML phylogenetic inference lecture\n\nWe will review Bui Quang Minhʻs ([Minh Bùi](https://bqminh.github.io/people/minh/)) [lecture on IQTREE2](https://github.com/simon-ho/SydneyPhyloWorkshop/blob/master/Lecture2_1.IQTREE.pdf) and how it addresses some issues in maximum likelihood inference of phylogenetics. \n\nHere is an illustration of phylogenetic inference by Maximum Likelihood (@fig-ml). The likelihood of the tree is calculated given the data (here, the DNA sequence at each position or site). Each site is considered an independent data point, and each variable site provides some information about how closely related the taxa are. The likelihood is an expression of a combined probability across all of the sites, assuming a particular substitution model (the best substitution models are what ModelFinder or PartitionFinder finds). The topology and branch lengths that provide the Maximum Likelihood of the data is the ML tree.  \n\n![Figure: An illustration of phylogenetic inference by Maximum Likelihood. A multiple sequence alignment (here, DNA sequences), and DNA substitution models are used to make evolutionary inferences among the taxa (four species t1 through t4). The data in this alignment (in this case a toy example with 18 sites) is converted to a set of site patterns. The site patterns are shown along with the number of times they occur in alignment. These site patterns are used to calculate the likelihood given the substitution model and a phylogenetic tree (in this case an unrooted four-taxon tree). It is also necessary to assume a substitution model to estimate evolutionary distances for pairs of sequences (distances are the number of substitutions that have occurred since sequences had a common ancestor). The evolutionary distance equation (d12) is based on the simple model proposed by Jukes and Cantor in 1969. The equation transforms the proportion of nucleotide differences between taxa 1 and 2 (p12 = 4/18; the four site patterns that differ between taxa 1 and 2 are indicated with asterisks) into an evolutionary distance (in this case d12=0.2635 substitutions per site).](../../images/Site_pattern_frequencies_models.jpg){#fig-ml}\n\n[Source: By EBraun68 - Own work, CC BY-SA 4.0](https://commons.wikimedia.org/w/index.php?curid=95686405)\n\n\n# Infer the Turtle Phylogeny with IQTREE\n\n## The theoretical problem\n\nThe position of turtles among vertebrates has been enigmatic for decades (@fig-turtle). At various times it has been allied more closely with mammals or lizards.  It is one of those truly hard biological problems. Even with the development of genomics, the position of turtles with respect to crocodiles and birds remains a hot topic of research as of late.  \n\n![The changing position of turtles. Image by Jeremy Brown, from IQTREE tutorial](../../images/turtle.png){#fig-turtle}\n\n[Source: Jeremy Brown](http://www.iqtree.org/workshop/molevol2022)\n\nImportantly, different groups have gotten different answers even with 100% bootstrap support at the nodes.  This highlights a problem that can occur when we have gene trees that conflict with the species tree. This can occur through incomplete lineage sorting (you will see ILS a lot in the literature; @fig-ils), or via hybridization, or other mechanisms. \n\n![Incomplete Lineage Sorting. The species tree (thick gray history) in relation to a gene tree (thin colored history). New lineages arising from murations in the gene are represented by changes in color. Differences in the history of the gene versus the species can occur when the two alleles in the population prior to the split of Dmel are maintained through to the split of Dere and Dyak, leading to maintenance of an ancestral polymorphism and incomplete lineage sorting. The species tree is now incongruent with the gene tree (tree 2). The greater the diversity in the ancestral population and the shorter the time between speciation events, the more likely we are to see gene-tree species tree conflict.](../../images/Incomplete-Lineage-Sorting.jpg){#fig-ils}\n\nSource: [@Pollard:2006]\n\n## The data\n\nThe original genomic data comes from [@Chiari:2012]. We are analyzing a subset of 29 genes from the original 248 genes, as well as a subset of taxa (to allow faster runs), presented in Bui Minhʻs [tutorial](http://www.iqtree.org/workshop/molevol2022). We will use IQTREE2 to generate the phylogenetic data, and then use R to analyze some of the output. We are just going to do the basics, for more indepth coverage see [Minh Buiʻs tutorial](http://www.iqtree.org/workshop/molevol2022). \n\n## Species Trees \n\nA shell script for thes IQTREE commands are in `iqtreerun.sh`\n\n### Simplest phylogeny\n\n[IQTREE2](http://www.iqtree.org) is the latest version of the IQTREE software. It runs on the command line, and each run generates a number of output files. To keep organized, it is a good idea to save your iqtree commands as a shell script, and to make input and output directories.  \n\nMac users open your `Terminal`, Windows users open your `Git-Bash`, navigate to your `TurtleTutorial` folder. \n\nThe simple command below will find the best-fit model using ModelFinder, reconstruct the ML tree, and calculate branch supports using the ultrafast boostrap. \n\n```{.bash filename=Terminal}\niqtree2 -s input/turtle.fa -B 1000 -T AUTO\n```\n\n__Run options explained:__\n\n- `-s input/turtle.fa` the path to the input alignment in `turtle.fa`.  \n- `-B 1000` 1000 replicates for the ultrafast bootstrap (Minh et al., 2013).  \n- `-T AUTO` auto select the best number of CPU cores to speed up the analysis.  \n\n__Output files (in `out`):__\n\n- `turtle.fa.iqtree` the main report file that is self-readable. You should look at this file to see the computational results. It also contains a textual representation of the final tree.  \n- `turtle.fa.treefile` the ML tree in NEWICK format, which can be visualized in FigTree or any other tree viewer program.  \n- `turtle.fa.log` log file of the entire run (also printed on the screen).  \n- `turtle.fa.ckp.gz` checkpoint file used to resume an interrupted analysis.  \n... and a few other files.  \n\n::: {.callout-tip}\n## Questions\n\n- Look at the report file `turtle.fa.iqtree`, and the log file `turtle.fa.log`.\n- What is the best-fit model name? What do you know about this model? (see [substitution models](http://www.iqtree.org/doc/Substitution-Models) available in IQ-TREE)\n- What are the AIC/AICc/BIC scores of this model and tree?\n- Visualise the tree `turtle.fa.treefile` in a tree viewer software like [FigTree](http://tree.bio.ed.ac.uk/software/figtree/) (or read into R with `ape` and `plot()`).  \n- What relationship among three trees does this tree support?\n- What is the ultrafast bootstrap support (%) for the relevant clade?\n- Does this tree agree with the published tree [@Chiari:2012]?\n:::\n\n### Species Tree partitioned by locus\n\nIt is well known that some genes evolve faster than others (for example nuclear protein-coding genes vs. mitochondrial genes vs. non-coding genes). Partitioning by locus allows the rate of substitution for each locus to be scaled to different evolutionary rates for an improved fit of the evolutionary model to the observed DNA sequence data. \n\nWe add a partition file indicating where the loci are in the alighment:\n\n```{.bash filename=Terminal}\n# infer the species tree with 1000 ultrafast bootstraps \n# and an edge-linked fully-partitioned model \niqtree2 -s input/turtle.fa -p input/turtle.nex --prefix out/species -B 1000 -nt AUTO\n```\n\n__Run options explained:__\n\n- `-p input/turtle.nex` the partition file that delimits the partitions in the alighment to specify an edge-linked proportional partition model (Chernomor et al., 2016). There is one set of branch lengths for the phylogeny, but each partition can have proportionally shorter or longer tree length (= same as slower or faster evolutionary rates, respectively).\n\n::: {.callout-tip}\n## Questions\n\n- Look at the report file `turtle.fa.iqtree`, and the log file `turtle.fa.log`.\n- What are the AIC/AICc/BIC scores of this model and tree? How does it compare?\n- What relationship among three trees does this tree support?\n:::\n\n\n### Gene Trees\n\nWe will now infer a separate phylogeny for each locus (= gene). It is really easy to compute gene trees in IQTREE. The same inputs are used as for the paritioned model, but we just tell IQTREE to estimate each gene tree separately with a different (`-S`) flag for the partition file:\n\n```{.bash filename=Terminal}\n# infer single-locus trees  \niqtree2 -s input/turtle.fa -S input/turtle.nex -m TEST --prefix out/loci -B 1000 \n```\n\n__Run options explained:__\n\n- `-S input/turtle.nex` to infer separate trees for every partition in `turtle.nex`. All output files are similar to a partition analysis, except that the tree `turtle.loci.treefile` now contains multiple trees - one for each gene.\n\n\n## Concordance factors ## \n\nTypcial phylogenetic inference methods essentially imply that gene trees and species tree are one and the same. However, it is well known that gene trees might be discordant (i.e., individual genes may have differet histories). We can actually check with large multilocus datasets (with many loci of sufficient length). Therefore, we now want to quantify the agreement between gene trees and species tree in a so-called concordance factor [@Minh:2020a].\n\nYou can now compute gene concordance factor (gCF) and site concordance factor (sCF) for the tree inferred under the partition model:\n\n```{.bash filename=Terminal}\n# locus modelfinder species tree vs. single-locus trees \niqtree2 -t out/species.treefile --gcf out/loci.treefile -s input/turtle.fa --scf 100 --prefix out/concord \n```\n\n__Run options explained:__\n\n- `-t out/species.treefile` to specify the species tree. We use tree under the partitioned model here, but you can of course use the other tree.\n- `--gcf out/loci.treefile` to specify a gene-trees file.\n- `--scf 100` to draw 100 random quartets when computing sCF.\n\n__Output files (in `out`):__\n\n- `concord.cf.tree`: tree file where branches are annotated with bootstrap/gCF/sCF values.\n- `concord.cf.stat`: a table file with various statistics for every branch of the tree.\n\nSimilarly, you can compute gCF and sCF for the tree under different species trees, for example if you generate an unpartitioned model:\n\n```{.bash filename=Terminal}\niqtree2 -t out/unpartitioned.treefile --gcf out/loci.treefile -s input/turtle.fa --scf 100 --prefix out/concord.unpartitioned \n```\n\n:::{.callout-tip}\nIf you need to redo any of these analyses, add the `-redo` flag at the end of the command. \n:::\n\n::: {.callout-note}\n## Definitions\n\n- Gene concordance factor (gCF) is the percentage of decisive gene trees concordant with a particular branch of the species tree (0% <= gCF(b) <= 100%). gCF=0% means that branch b does not occur in any gene trees, whereas gCF=100% means that branch b occurs in every gene tree.  \n- Site concordance factor (sCF) is the percentage of decisive (parsimony informative) alignment sites supporting a particular branch of the species tree (~33% <= sCF(b) <= 100%). sCF<33% means that another discordant branch b’ is more supported, whereas sCF=100% means that branch b is supported by all sites.  \n- __CAUTION__ when gCF ~ 0% or sCF < 33%, even if boostrap supports are ~100%!\n- __GREAT__ when gCF and sCF > 50% (i.e., branch is supported by a majority of genes and sites).\n:::\n\n::: {.callout-tip}\n## Questions\n\n- Visualise `concord.cf.tree.nex` in FigTree.\n- Explore gene concordance factor (gCF), gene discordance factors (gDF1, gDF2, gDFP), site concordance factor (sCF) and site discordance factors (sDF1, sDF2).\n- How do gCF and sCF values look compared with bootstrap supports?\n:::\n\n# Further analyses of IQTREE outputs\n\nThe code and analysis that follows was borrowed and adapted from Rob Lanfearʻs excellent blog on exploring gene-tree species-tree concordance <http://www.robertlanfear.com/blog/files/concordance_factors.html>. This is an excellent example of how to integrate output from other analysis software with R code. \n\nAn R script for these analyses is in `concordance.R`\n\n## Using concordance factors to understand your data\n\nThe first step is just to look at the concordance factors on the tree. To do this, load the output tree (concord.cf.tree) in any tree viewer such as Figtree or you can use R. In this tree, each branch label shows bootstrap / gCF / sCF.\n\nWe can also plot the trees using `ggtree` (but for a first look around I usually use FigTree).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(viridis)\nrequire(GGally)\nrequire(entropy)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in library(package, lib.loc = lib.loc, character.only = TRUE,\nlogical.return = TRUE, : there is no package called 'entropy'\n```\n\n\n:::\n\n```{.r .cell-code}\nrequire(ggtree)\nrequire(treeio)\nrequire(tidytree)\nrequire(ggplot2)\nrequire(dplyr)\nrequire(ggrepel)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# read the data\nd = read.delim(\"out/concord.cf.stat\", header = T, comment.char='#')\n               \n# rename the bootstrap and branchlength columns\nnames(d)[names(d)==\"Label\"] = \"bootstrap\"\nnames(d)[names(d)==\"Length\"] = \"branchlength\"\n\n# plot the tree\ntree <- read.iqtree(\"out/concord.cf.tree\")  # read in tree file\ntib <- as_tibble(tree)\nd$node <- d$ID + 1  # need to +1 to make IQTREE node numbers = ggtree \n\n# merge the tree and data \ntd <- full_join(tib, d, by = \"node\")  # combine the tree (tib) and data (d)\ntd <- as.treedata(td)       # coerce to treedata format (td)\n\nggtree(td) +          # plot tree\n  theme(legend.position=\"right\") +\n  geom_tiplab() +                         # add tip labels\n  geom_label2(aes(label=label, subset=!isTip), color=\"black\")  # add node labels \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nThe turtle clade contains __Chelonoidis__ to __Phrynops__. Which clade do turtles group with? This part of the tree immediately illustrates the most important point: bootstraps and concordance factors are giving you very different information about each branch in the tree. Just take a look at how different the three numbers can be!\n\n# How concordance factors relate to each other and to bootstraps\n\nMore generally, we can look at the links between bootstrap, gCF, and sCF across all nodes of the tree. This is simple to do in R, because IQ-TREE outputs a tab-delimited file that’s easy to read called concord.cf.stat. This file has one row per branch in the tree, and gives a lot of details on the statistics for each branch. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the values\nggplot(d, aes(x = gCF, y = sCF)) + \n    geom_point(aes(colour = bootstrap)) + \n    scale_colour_viridis(direction = -1) + \n    xlim(0, 100) +\n    ylim(0, 100) +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nThis plot shows a few important things. First, _low bootstrap values (bright colours) coincide with the lowest gCF and sCF values, as expected_. You can only get a low bootstrap value when the there’s very limited information on that branch in the alignment. And if there’s very little information, there will be very few sites (and therefore genes) that can support a branch. \n\n__However, it is possible to have low gCF and sCF even with high bootstrap values.__ It turns out that _bootstrap values max out at 100% pretty quickly_, which tends to happen with very large datasets such as provided by Next-Gen sequencing. \n\nFinally, __sCF values have a minimum of ~30%__, but __gCF values can go all the way to 0%__. This means that an sCF value ~30% is as low as you can possibly get. The range of possible values are simply a reflection of how these statistics are calculated. sCF values are calculated by comparing the three possible resolutions of quartet around a node, so when the data are completely equivocal about these resolutions, we expect an sCF value of 1 out of 3 or 33%. gCF values, on the other hand, are calculated from full gene trees, such that there are many more than 3 possible resolutions around a node, and the gCF value can be as low as 0% if no single gene tree contains a branch that’s present in the reference tree. This can happen when the genes are too short to contain informative sites (and happens more often deeper in the tree), or noisy data -- a combination of biology and stochastic error that leads to a lot of gene-tree discordance. \n\nSometimes we want to label points. `ggrepel()` is very helpful for this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# label the points\nggplot(d, aes(x = gCF, y = sCF, label = ID)) + \n    geom_point(aes(colour = bootstrap)) + \n    scale_colour_viridis(direction = -1) + \n    xlim(0, 100) +\n    ylim(0, 100) +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    geom_text_repel()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n# Digging deeper using discordance factors\n\nFirst we need to find the ID of the problematic node:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# show branches of interest\nd[(d$ID==20|d$ID==22),]  # these have lower bootstrap support than the others and have low gCF or sCF\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID   gCF gCF_N gDF1 gDF1_N  gDF2 gDF2_N  gDFP gDFP_N gN   sCF sCF_N  sDF1\n4 20 75.00     3 0.00      0 25.00      1  0.00      0  4 38.24 26.35 28.02\n6 22 48.28    14 3.45      1 17.24      5 31.03      9 29 36.13 57.59 22.17\n  sDF1_N  sDF2 sDF2_N     sN bootstrap branchlength node\n4  19.59 33.75  23.71  69.65        51   0.00355984   21\n6  37.78 39.70  72.90 168.27        81   0.01865970   23\n```\n\n\n:::\n:::\n\n\n\nWe can see that the problematic nodes have very short branch lengths, which is consistent with possible incomplete lineage sorting. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the tree with colors to highlight support\n\nggtree(td, aes(color=SH_aLRT), size=2) +          # plot tree\n  theme(legend.position=\"right\") +\n  geom_tiplab(size=5) +                         # add tip labels\n  geom_label2(aes(label=label, subset=!isTip), color=\"black\") + # add node labels \n  geom_label2(aes(label=label, subset= (!isTip & (node==22))), color=\"black\", fill=\"yellow\") +                  # highlight low bootstrap support \n  scale_color_continuous(low=\"yellow\", high=\"purple\") # color the branches by bootstrap\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggtree(td) +                                      # plot tree\n  geom_tiplab() +                               # plot tip labels\n  geom_label2(aes(label=node, subset= !isTip))  # plot node numbers \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n:::\n\n\n\n# Using concordance factors to test the assumptions of an ILS model\n\nIf the discordance among gene trees and sites come from _incomplete lineage sorting_, different genes should randomly support one or the other of the discordant topologies. Thus, we can make a simple and testable prediction: that the number of gene trees or sites supporting the two discordant topologies should be roughly equal. Both of these ideas have been around for some time (for genes [link to Huson et al & Steel 2005 Recomb] and for sites [link to Greene et al 2010]), and the IQ-TREE output lets us test them very easily. \n\nThe basic idea is that we count up the genes or sites supporting the two discordant topologies, and use a chi-square test to see if they’re significantly different. This requires a number of assumptions to hold (see the papers linked above). A simple way to calculate the probability that the data can reject __equal frequencies__ of discordant toplogogies (EFp) for genes (gEFp) and for sites (sEFp). In this case failure to reject the hypothesis of equal frequencies is compatible with ILS. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first we use a slightly modified chisq function\n# which behaves nicely when you feed it zeros\nchisq = function(DF1, DF2, N){\n    tryCatch({\n        # converts percentages to counts, runs chisq, gets pvalue\n        chisq.test(c(round(DF1*N)/100, round(DF2*N)/100))$p.value\n    },\n    error = function(err) {\n        # errors come if you give chisq two zeros\n        # but here we're sure that there's no difference\n        return(1.0)\n    })\n}\n\ne = d %>% \n    group_by(ID) %>%\n    mutate(gEF_p = chisq(gDF1, gDF2, gN)) %>%\n    mutate(sEF_p = chisq(sDF1, sDF2, sN))\n    \n\nsubset(data.frame(e), (gEF_p < 0.05 | sEF_p < 0.05))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID   gCF gCF_N gDF1 gDF1_N  gDF2 gDF2_N  gDFP gDFP_N gN   sCF sCF_N  sDF1\n6 22 48.28    14 3.45      1 17.24      5 31.03      9 29 36.13 57.59 22.17\n  sDF1_N sDF2 sDF2_N     sN bootstrap branchlength node     gEF_p       sEF_p\n6  37.78 39.7   72.9 168.27        81    0.0186597   23 0.1024704 0.003849915\n```\n\n\n:::\n:::\n\n\n\n\n# Internode certainty\n\nThe last measure to quantify evidence for each branch is the __internode certainty__ [@Salichos:2014]. \n\nthe conflict along a given branch is\n\nInternode certainty quantifies the degree of certainty for each branch (individual internode). It finds the two most common conflicting bipartitions, and measures the log magnitude of their difference. \n\nWe determine concordance in a clever way using set theory. We can think of each branch as splitting the tree into two subsets of taxa (bipartitions). What is so clever is that we donʻt have to compare the toplogies of the subtrees, just the taxa included. The task then comes down to checking for compatible intersections of the bipartitions. This makes it very easy (=fast) computationally. Hereʻs a figure from the paper by @fig-internode-conflict [@Salichos:2014] \n\n![Compatible and conflicting bipartitions. Bipartition A = {a, b, c, d, e | f, g, h, i, j} is composed of the partitions A1 = {{a, b, c, d, e}} and A2 = {f, g, h, i, j}, where a, b, c, d, e, f, g, h, i, and j are taxa. Bipartition B = {a, b, c | d, e, f, g, h, i, j} is composed of the partitions B1 = {a, b, c} and B2 = {d, e, f, g, h, i, j}, and bipartition C = {a, b, c, d, g | e, f, h, i, j} is composed of the partitions C1 = {a, b, c, d, g} and C2 = {e, f, h, i, j}. ](../../images/internode-conflict.png){#fig-internode-conflict}\n\n[Source: @Salichos:2014]\n\n\nWe check the compatibility of the biparitions by checking the intersections of their each possible set of bipartition pairs. \n\n:::{.callout-note}\n# The definition of compatibility\nTwo bipartitions $A=A_1 | A_2$ and $B=B_1 | B_2$ from the same taxon set are __compatible__ _if and only if_ at least one of the intersections of the four bipartition pairs ($A_1 \\cap B_1$, $A_1 \\cap B_2$, $A_2 \\cap B_1$, $A_2 \\cap B_2$) is empty (see citations in @Salichos:2014). \n:::\n\nBipartitions A and B are compatible because one of the intersections of their bipartition pairs ($A_2 \\cap B_1$) is empty. \n\n$$\nA_2 \\cap B_1 =  \\{f, g, h, i, j\\} \\cap \\{a, b, c\\} = \\emptyset\n$$\n\nBipartitions B and C are also compatible ($B_1 \\cap C_2$ is empty). \n\n$$\nB_1 \\cap C_2 =  \\{a, b, c\\} \\cap \\{e, f, h, i, j\\} = \\emptyset\n$$\n\nIn contrast, bipartition C conflicts with A (or is incompatible) because none of the four intersections are empty:\n\n$$\n\\begin{aligned}\nA_1 \\cap C_1 &=  \\{{a, b, c, d, e}\\} \\cap \\{a, b, c, d, g\\} = \\{a, b, c, d\\}  \\\\\nA_1 \\cap C_2 &=  \\{{a, b, c, d, e}\\} \\cap \\{e, f, h, i, j\\} = \\{e\\}  \\\\\nA_2 \\cap C_1 &=  \\{{f, g, h, i, j}\\} \\cap \\{a, b, c, d, g\\} = \\{a, b, c, d\\}  \\\\  \nA_2 \\cap C_2 &=  \\{{f, g, h, i, j}\\} \\cap \\{e, f, h, i, j\\} = \\{e\\}  \n\\end{aligned}\n$$\n\nFor a given branch, Internode Certainty (IC) values reflect the degree of conflict between the bipartition defining the branch (say X) and the most frequent conflicting biparition (say Y), which we can get by counting the number of concordant genes or sites for each bipartition. IC is then defined by: \n\n$$\n\\begin{aligned}\nIC &= log_2(n) + \\sum_{n=1}^2 P(X_n)log_2[P(X_n)] \\\\\n   &= 1 + P(X)log_2[P(X)] + P(Y)log_2[P(Y)], \n\\end{aligned}\n$$\nwhere the frequencies of the bipartitons are: \n\n$$\n\\begin{aligned}\nP(X) = X/(X + Y), \\\\  \nP(Y) = Y/(X + Y) \n\\end{aligned}\n$$\nand   $P(X) + P(Y) = 1.$\n\nTherefore, IC values at or close to 1 indicate support for the given branch (i.e., absence of conflict), and IC values at or close to 0 indicate maximum conflict (i.e., equal support for both bipartitions).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate internode certainty\n\nIC = function(CF, DF1, DF2, N){\n    \n    # convert to counts\n    X = CF * N / 100\n    Y = max(DF1, DF2) * N / 100\n        \n    pX = X/(X+Y)\n    pY = Y/(X+Y)\n    \n    IC = 1 + pX * log2(pX) +\n             pY * log2(pY)\n\n    return(IC)\n}\n\n\ne = e %>% \n    group_by(ID) %>%\n    mutate(gIC = IC(gCF, gDF1, gDF2, gN)) %>%\n    mutate(sIC = IC(sCF, sDF1, sDF2, sN))\n\n# plot it\nggpairs(e, columns = c(\"gCF\", \"sCF\", \"bootstrap\", \"gEF_p\", \"sEF_p\", \"gIC\", \"sIC\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-tip}\n## Questions\n\n- Which nodes have IC near zero? \n- How does it correspond to gCF, sCF, and bootstrap support?\n:::\n\n\nSee Rob Lanfearʻs blog for detailed explanations of the following calculations <http://www.robertlanfear.com/blog/files/concordance_factors.html>. This is an excellent example of how to integrate output from other analysis software with R code. \n\n\n\n# IQTREE documentation\n\n- [IQTREE quickstart]](http://www.iqtree.org/doc/Quickstart)      \n\n- IQTREE documentation <http://www.iqtree.org/doc/> \n      \n- Command Line Reference (when you get more familiar with it) <http://www.iqtree.org/doc/Command-Reference>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}