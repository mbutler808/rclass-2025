{
  "hash": "a2bc2da4f6b4ddcb1d760acf3e701ed3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Joining data with dplyr\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Combining datasets via merging or joining is a power tool\"\ndate: 2025-03-13\ncategories: [module 3, week 7, tidyr, tidyverse, dplyr, tibble, pipe]\n---\n\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/relational-data>\n2.  <https://rafalab.github.io/dsbook/joining-tables>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-08-joining-data-in-r/>\n-   <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics>\n-   <https://r4ds.had.co.nz/relational-data>\n-   <https://rafalab.github.io/dsbook/joining-tables>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to define relational data and keys\n-   Be able to define the three types of join functions for relational data\n-   Be able to implement mutational join functions\n:::\n\n## New Packages\n\nYou will have to install if you donʻt already have them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"gapminder\")  # a dataset package\n```\n:::\n\n\n\n# Overview\n\nLast time we talked about tidy data. One common issue is that people sometimes use column names to store data. For example take a look at this built-in dataset that comes with `tidyr` on **religion and income survey data** with the number of respondents with income range in column name.\n\n\n# Joining data (a.k.a. Merging)\n\n## Relational data\n\nData analyses rarely involve only a single table of data.\n\nTypically you have many tables of data, and you **must combine the datasets** to answer the questions that you are interested in.  Some examples include morphology and ecology data on the same species, or sequence data and metadata. \n\nCollectively, **multiple tables of data are called relational data** because it is the *relations*, not just the individual datasets, that are important.\n\nRelations are **always defined between a pair of tables**. All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair.\n\nSometimes both elements of a pair can be in the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents, or if you have nodes in a phylogeny and each is linked to an ancestral node.\n\nRelational data are combined with **merges or joins**.\n\n## Example with `merge()`\n\nLetʻs use the `geospiza` data from the `geiger` package to practice merging with the base R `merge()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(geiger)\ndata(geospiza)   # load the dataset into the workspace\nls()               # list the objects in the workspace\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"geospiza\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngeospiza\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$geospiza.tree\n\nPhylogenetic tree with 14 tips and 13 internal nodes.\n\nTip labels:\n  fuliginosa, fortis, magnirostris, conirostris, scandens, difficilis, ...\n\nRooted; includes branch length(s).\n\n$geospiza.data\n                wingL  tarsusL  culmenL    beakD   gonysW\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100 1.929983\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nfuliginosa   4.132957 2.806514 2.094971 1.941157 1.845379\npallida      4.265425 3.089450 2.430250 2.016350 1.949125\nfusca        3.975393 2.936536 2.051843 1.191264 1.401186\nparvulus     4.131600 2.973060 1.974420 1.873540 1.813340\npauper       4.232500 3.035900 2.187000 2.073400 1.962100\nPinaroloxias 4.188600 2.980200 2.311100 1.547500 1.630100\nPlatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\n\n$phy\n\nPhylogenetic tree with 14 tips and 13 internal nodes.\n\nTip labels:\n  fuliginosa, fortis, magnirostris, conirostris, scandens, difficilis, ...\n\nRooted; includes branch length(s).\n\n$dat\n                wingL  tarsusL  culmenL    beakD   gonysW\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100 1.929983\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nfuliginosa   4.132957 2.806514 2.094971 1.941157 1.845379\npallida      4.265425 3.089450 2.430250 2.016350 1.949125\nfusca        3.975393 2.936536 2.051843 1.191264 1.401186\nparvulus     4.131600 2.973060 1.974420 1.873540 1.813340\npauper       4.232500 3.035900 2.187000 2.073400 1.962100\nPinaroloxias 4.188600 2.980200 2.311100 1.547500 1.630100\nPlatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\n```\n\n\n:::\n\n```{.r .cell-code}\ngeo <- geospiza$dat  # save the morphometric data as geo\n```\n:::\n\n\n\nThis is a 5 column dataframe. Letʻs take just the `tarsusL` data to build our example dataset:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarsusL <- geo[,\"tarsusL\"]  # geo is a matrix, select tarsusL column\ngeot <- data.frame(tarsusL, \"ecology\" = LETTERS[1:length(tarsusL)])\n```\n:::\n\n\n\nOften we will be merging data that donʻt perfectly match. Some parts of the data will be missing, for example we may only have ecology data for the first five species.  The question is what do you want the merge behavior to be? \n\nThe default is to drop all observations that are not in BOTH datasets. Here we merge the original `geo` with only the first five rows of `geot`: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n                    # only maches to both datasets are included\nmerge(x=geo[,\"tarsusL\"], y=geot[1:5, ], by= \"row.names\")    \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Row.names        x  tarsusL ecology\n1  conirostris 2.984200 2.984200       B\n2   difficilis 2.898917 2.898917       C\n3       fortis 2.894717 2.894717       E\n4 magnirostris 3.038950 3.038950       A\n5     scandens 2.929033 2.929033       D\n```\n\n\n:::\n:::\n\n\n\nIf we want to keep everything, use the `all=T` flag: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n                    # all species in both datasets are included\nmerge(x=geo[,\"tarsusL\"], y=geot[1:5,], by= \"row.names\", all=T)    \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Row.names        x  tarsusL ecology\n1   conirostris 2.984200 2.984200       B\n2    difficilis 2.898917 2.898917       C\n3        fortis 2.894717 2.894717       E\n4    fuliginosa 2.806514       NA    <NA>\n5         fusca 2.936536       NA    <NA>\n6  magnirostris 3.038950 3.038950       A\n7       pallida 3.089450       NA    <NA>\n8      parvulus 2.973060       NA    <NA>\n9        pauper 3.035900       NA    <NA>\n10 Pinaroloxias 2.980200       NA    <NA>\n11   Platyspiza 3.270543       NA    <NA>\n12   psittacula 3.049120       NA    <NA>\n13     scandens 2.929033 2.929033       D\n```\n\n\n:::\n:::\n\n\n\nThere is also `all.x` which keeps all values of the first data table but drops non-matching rows of the second table, and `all.y` which keeps all of the second. \n\n\nThe results of `merge` are sorted by default on the sort key. To turn it off:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo <- geo[rev(rownames(geo)), ]   # reverse the species order of geo\n                     # merge on geo first, then geot\nmerge(x=geo[,\"tarsusL\"], y=geot[1:5, ], by= \"row.names\", sort=F)   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Row.names        x  tarsusL ecology\n1       fortis 2.894717 2.894717       E\n2     scandens 2.929033 2.929033       D\n3   difficilis 2.898917 2.898917       C\n4  conirostris 2.984200 2.984200       B\n5 magnirostris 3.038950 3.038950       A\n```\n\n\n:::\n\n```{.r .cell-code}\n                     # geot first, then geo\nmerge(x=geot[1:5,], y=geo[,\"tarsusL\"], by= \"row.names\", sort=F)   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Row.names  tarsusL ecology        y\n1 magnirostris 3.038950       A 3.038950\n2  conirostris 2.984200       B 2.984200\n3   difficilis 2.898917       C 2.898917\n4     scandens 2.929033       D 2.929033\n5       fortis 2.894717       E 2.894717\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\n-   In a `merge`, the non-key columns are copied over into the new table. \n:::\n\nCheck out the help page for `?merge` for more info. \n\n# Keys\n\nThe **variables used to connect each pair of tables** are called **keys**. A key is a variable (or set of variables) that __uniquely identifies an observation__. In simple cases, a single variable is sufficient to identify an observation.\n\nIn the example above the key was the __species names__, which was contained in the `row.names` attribute. The key was specified in the merge in the `by=` argument. A merge or join key is a generic concept that is used in many database operations. \n\n::: callout-tip\n### Note\n\nThere are two types of keys:\n\n-   A **primary key** uniquely identifies an observation in its own table.\n-   A **foreign key** uniquely identifies an observation in another table.\n:::\n\nLet's consider an example to help us understand the difference between a **primary key** and **foreign key**.\n\n## Example of keys\n\nImagine you are conduct a study and **collecting data on subjects and a health outcome**.\n\nOften, subjects will **have multiple observations** (a longitudinal study). Similarly, we may record other information, such as the type of housing.\n\n### The first table\n\nThis code creates a simple table with some made up data about some hypothetical subjects' outcomes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\noutcomes <- tibble(\n        id = rep(c(\"a\", \"b\", \"c\"), each = 3),\n        visit = rep(0:2, 3),\n        outcome = rnorm(3 * 3, 3)\n)\n\nprint(outcomes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 3\n  id    visit outcome\n  <chr> <int>   <dbl>\n1 a         0    2.68\n2 a         1    3.30\n3 a         2    2.83\n4 b         0    1.94\n5 b         1    1.19\n6 b         2    3.03\n7 c         0    3.86\n8 c         1    3.12\n9 c         2    2.15\n```\n\n\n:::\n:::\n\n\n\nNote that subjects are labeled by a unique identifer in the `id` column.\n\n### A second table\n\nHere is some code to create a second table containing  data about the hypothetical subjects' housing type.\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\")\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  id    house   \n  <chr> <chr>   \n1 a     detached\n2 b     rowhouse\n3 c     rowhouse\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\n### Question\n\nWhat is the **primary key** and **foreign key**?\n\n-   The `outcomes$id` is a **primary key** because it uniquely identifies each subject in the `outcomes` table.\n-   The `subjects$id` is a **foreign key** because it appears in the `subjects` table where it matches each subject to a unique `id`.\n:::\n\n\n\n# Joining in `dplyr`\n\nIn `dplyr`, merges are called joins (both are used in database science) and introduces a vocabulary that names each of these situations. \n\n::: callout-tip\n### Three important families of joins\n\n-   [**Mutating joins**](https://r4ds.had.co.nz/relational-data.html#mutating-joins): add new variables to one data frame from matching observations in another.\n\n    -   This is a typical __merge__ operation. A mutating join **combines variables from two tables** into a new table. Observations in the two tables are matched by their keys, with  the variables from the two tables copied into the new table. It is a mutating join because it adds columns with the merge, and in that way is analogous to the `mutate()` function for dataframes.  \n    -   See @sec-mutjoins for Table of mutating joins.\n\n-   [**Filtering joins**](https://r4ds.had.co.nz/relational-data.html#filtering-joins): filter observations from one data frame based on whether or not they match an observation in the other table\n\n    -   Filtering joins are a way to filter one dataset by observations in another dataset (they are more filter and less join). \n    -   Filtering joins **match observations** by a key, as usual, **but select the observations that match** (not the variables). In other words, this type of join filters observations from one data frame based on whether or not they match an observation in the other.  \n    -   Two types: `semi_join(x, y)` and `anti_join(x, y)`.\n\n-   [**Set operations**](https://r4ds.had.co.nz/relational-data.html#set-operations): treat observations as if they were set elements.\n\n    -   Set operations can be useful when you want to break a single complex filter into simpler pieces. All these operations work with a complete row, comparing the values of every variable. These expect the x and y inputs to have the same variables, and treat the observations like sets:  \n    -   Examples of set operations: `intersect(x, y)`, `union(x, y)`, and `setdiff(x, y)`.\n:::\n\n\n# Types of mutating joins {#sec-mutjoins}\n\nThe `dplyr` package provides a set of **functions for joining two data frames** into a single data frame based on a set of key columns.\n\nThere are several functions in the `*_join()` family.\n\n-   These functions all merge together two data frames\n-   They differ in how they handle observations that exist in one but not both data frames.\n\nHere, are the **four functions from this family** that you will likely use the most often:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|Function       |What it includes in merged data frame                                                                     |\n|:--------------|:---------------------------------------------------------------------------------------------------------|\n|`left_join()`  |Includes all observations in the left data frame, whether or not there is a match in the right data frame |\n|`right_join()` |Includes all observations in the right data frame, whether or not there is a match in the left data frame |\n|`inner_join()` |Includes only observations that are in both data frames                                                   |\n|`full_join()`  |Includes all observations from both data frames                                                           |\n\n\n:::\n:::\n\n\n\n![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png)\n\n\\[[Source from R for Data Science](https://r4ds.had.co.nz/relational-data#relational-data)\\]\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Using prose, describe how the variables and observations are organised in a tidy dataset versus an non-tidy dataset.\n\n2.  What do the extra and fill arguments do in `separate()`? Experiment with the various options for the following two toy datasets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n```\n:::\n\n\n\n3.  Both `unite()` and `separate()` have a remove argument. What does it do? Why would you set it to FALSE?\n\n4.  Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one `unite()`?\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}